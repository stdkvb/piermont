/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-input-mask";
exports.ids = ["vendor-chunks/react-input-mask"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-input-mask/index.js":
/*!************************************************!*\
  !*** ./node_modules/react-input-mask/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint-disable import/no-unresolved */\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./lib/react-input-mask.development.js */ \"(ssr)/./node_modules/react-input-mask/lib/react-input-mask.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtaW5wdXQtbWFzay9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsOEpBQWlFO0FBQ25FIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGllcm1vbnQvLi9ub2RlX21vZHVsZXMvcmVhY3QtaW5wdXQtbWFzay9pbmRleC5qcz9lMzYyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9uby11bnJlc29sdmVkICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvcmVhY3QtaW5wdXQtbWFzay5wcm9kdWN0aW9uLm1pbi5qc1wiKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL3JlYWN0LWlucHV0LW1hc2suZGV2ZWxvcG1lbnQuanNcIik7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-input-mask/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-input-mask/lib/react-input-mask.development.js":
/*!***************************************************************************!*\
  !*** ./node_modules/react-input-mask/lib/react-input-mask.development.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar React__default = _interopDefault(React);\nvar reactDom = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\nvar PropTypes = _interopDefault(__webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\"));\nvar invariant = _interopDefault(__webpack_require__(/*! invariant */ \"(ssr)/./node_modules/invariant/invariant.js\"));\nvar warning = _interopDefault(__webpack_require__(/*! warning */ \"(ssr)/./node_modules/warning/warning.js\"));\n\nfunction _defaults2(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n\n  _defaults2(subClass, superClass);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction defer(fn) {\n  return requestAnimationFrame(fn);\n}\nfunction cancelDefer(deferId) {\n  cancelAnimationFrame(deferId);\n}\n\nfunction setInputSelection(input, start, end) {\n  if (end === undefined) {\n    end = start;\n  }\n\n  input.setSelectionRange(start, end);\n}\nfunction getInputSelection(input) {\n  var start = input.selectionStart;\n  var end = input.selectionEnd;\n  return {\n    start: start,\n    end: end,\n    length: end - start\n  };\n}\nfunction isInputFocused(input) {\n  var inputDocument = input.ownerDocument;\n  return inputDocument.hasFocus() && inputDocument.activeElement === input;\n}\n\n// Element's window may differ from the one within React instance\n// if element rendered within iframe.\n// See https://github.com/sanniassin/react-input-mask/issues/182\nfunction getElementDocument(element) {\n  return element == null ? void 0 : element.ownerDocument;\n}\nfunction getElementWindow(element) {\n  var _getElementDocument;\n\n  return (_getElementDocument = getElementDocument(element)) == null ? void 0 : _getElementDocument.defaultView;\n}\nfunction isDOMElement(element) {\n  var elementWindow = getElementWindow(element);\n  return !!elementWindow && element instanceof elementWindow.HTMLElement;\n}\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\nfunction findLastIndex(array, predicate) {\n  for (var i = array.length - 1; i >= 0; i--) {\n    var x = array[i];\n\n    if (predicate(x, i)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\nfunction repeat(string, n) {\n  if (n === void 0) {\n    n = 1;\n  }\n\n  var result = \"\";\n\n  for (var i = 0; i < n; i++) {\n    result += string;\n  }\n\n  return result;\n}\nfunction toString(value) {\n  return \"\" + value;\n}\n\nfunction useInputElement(inputRef) {\n  return React.useCallback(function () {\n    var input = inputRef.current;\n    var isDOMNode = typeof window !== \"undefined\" && isDOMElement(input); // workaround for react-test-renderer\n    // https://github.com/sanniassin/react-input-mask/issues/147\n\n    if (!input || !isDOMNode) {\n      return null;\n    }\n\n    if (input.nodeName !== \"INPUT\") {\n      input = input.querySelector(\"input\");\n    }\n\n    if (!input) {\n      throw new Error(\"react-input-mask: inputComponent doesn't contain input node\");\n    }\n\n    return input;\n  }, [inputRef]);\n}\n\nfunction useDeferLoop(callback) {\n  var deferIdRef = React.useRef(null);\n  var runLoop = React.useCallback(function () {\n    // If there are simulated focus events, runLoop could be\n    // called multiple times without blur or re-render\n    if (deferIdRef.current !== null) {\n      return;\n    }\n\n    function loop() {\n      callback();\n      deferIdRef.current = defer(loop);\n    }\n\n    loop();\n  }, [callback]);\n  var stopLoop = React.useCallback(function () {\n    cancelDefer(deferIdRef.current);\n    deferIdRef.current = null;\n  }, []);\n  React.useEffect(function () {\n    if (deferIdRef.current) {\n      stopLoop();\n      runLoop();\n    }\n  }, [runLoop, stopLoop]);\n  React.useEffect(cancelDefer, []);\n  return [runLoop, stopLoop];\n}\n\nfunction useSelection(inputRef, isMasked) {\n  var selectionRef = React.useRef({\n    start: null,\n    end: null\n  });\n  var getInputElement = useInputElement(inputRef);\n  var getSelection = React.useCallback(function () {\n    var input = getInputElement();\n    return getInputSelection(input);\n  }, [getInputElement]);\n  var getLastSelection = React.useCallback(function () {\n    return selectionRef.current;\n  }, []);\n  var setSelection = React.useCallback(function (selection) {\n    var input = getInputElement(); // Don't change selection on unfocused input\n    // because Safari sets focus on selection change (#154)\n\n    if (!input || !isInputFocused(input)) {\n      return;\n    }\n\n    setInputSelection(input, selection.start, selection.end); // Use actual selection in case the requested one was out of range\n\n    selectionRef.current = getSelection();\n  }, [getInputElement, getSelection]);\n  var selectionLoop = React.useCallback(function () {\n    selectionRef.current = getSelection();\n  }, [getSelection]);\n\n  var _useDeferLoop = useDeferLoop(selectionLoop),\n      runSelectionLoop = _useDeferLoop[0],\n      stopSelectionLoop = _useDeferLoop[1];\n\n  React.useLayoutEffect(function () {\n    if (!isMasked) {\n      return;\n    }\n\n    var input = getInputElement();\n    input.addEventListener(\"focus\", runSelectionLoop);\n    input.addEventListener(\"blur\", stopSelectionLoop);\n\n    if (isInputFocused(input)) {\n      runSelectionLoop();\n    }\n\n    return function () {\n      input.removeEventListener(\"focus\", runSelectionLoop);\n      input.removeEventListener(\"blur\", stopSelectionLoop);\n      stopSelectionLoop();\n    };\n  });\n  return {\n    getSelection: getSelection,\n    getLastSelection: getLastSelection,\n    setSelection: setSelection\n  };\n}\n\nfunction useValue(inputRef, initialValue) {\n  var getInputElement = useInputElement(inputRef);\n  var valueRef = React.useRef(initialValue);\n  var getValue = React.useCallback(function () {\n    var input = getInputElement();\n    return input.value;\n  }, [getInputElement]);\n  var getLastValue = React.useCallback(function () {\n    return valueRef.current;\n  }, []);\n  var setValue = React.useCallback(function (newValue) {\n    valueRef.current = newValue;\n    var input = getInputElement();\n\n    if (input) {\n      input.value = newValue;\n    }\n  }, [getInputElement]);\n  return {\n    getValue: getValue,\n    getLastValue: getLastValue,\n    setValue: setValue\n  };\n}\n\nfunction useInputState(initialValue, isMasked) {\n  var inputRef = React.useRef();\n\n  var _useSelection = useSelection(inputRef, isMasked),\n      getSelection = _useSelection.getSelection,\n      getLastSelection = _useSelection.getLastSelection,\n      setSelection = _useSelection.setSelection;\n\n  var _useValue = useValue(inputRef, initialValue),\n      getValue = _useValue.getValue,\n      getLastValue = _useValue.getLastValue,\n      setValue = _useValue.setValue;\n\n  function getLastInputState() {\n    return {\n      value: getLastValue(),\n      selection: getLastSelection()\n    };\n  }\n\n  function getInputState() {\n    return {\n      value: getValue(),\n      selection: getSelection()\n    };\n  }\n\n  function setInputState(_ref) {\n    var value = _ref.value,\n        selection = _ref.selection;\n    setValue(value);\n    setSelection(selection);\n  }\n\n  return {\n    inputRef: inputRef,\n    getInputState: getInputState,\n    getLastInputState: getLastInputState,\n    setInputState: setInputState\n  };\n}\nfunction usePrevious(value) {\n  var ref = React.useRef();\n  React.useEffect(function () {\n    ref.current = value;\n  });\n  return ref.current;\n}\n\nvar CONTROLLED_PROPS = [\"disabled\", \"onBlur\", \"onChange\", \"onFocus\", \"onMouseDown\", \"readOnly\", \"value\"];\nvar defaultFormatChars = {\n  \"9\": /[0-9]/,\n  a: /[A-Za-z]/,\n  \"*\": /[A-Za-z0-9]/\n};\n\nfunction validateMaxLength(props) {\n   true ? warning(!props.maxLength || !props.mask, \"react-input-mask: maxLength property shouldn't be passed to the masked input. It breaks masking and unnecessary because length is limited by the mask length.\") : 0;\n}\nfunction validateMaskPlaceholder(props) {\n  var mask = props.mask,\n      maskPlaceholder = props.maskPlaceholder;\n  !(!mask || !maskPlaceholder || maskPlaceholder.length === 1 || maskPlaceholder.length === mask.length) ?  true ? invariant(false, \"react-input-mask: maskPlaceholder should either be a single character or have the same length as the mask:\\n\" + (\"mask: \" + mask + \"\\n\") + (\"maskPlaceholder: \" + maskPlaceholder)) : 0 : void 0;\n}\nfunction validateChildren(props, inputElement) {\n  var conflictProps = CONTROLLED_PROPS.filter(function (propId) {\n    return inputElement.props[propId] != null && inputElement.props[propId] !== props[propId];\n  });\n  !!conflictProps.length ?  true ? invariant(false, \"react-input-mask: the following props should be passed to the InputMask component, not to children: \" + conflictProps.join(\",\")) : 0 : void 0;\n}\n\nfunction parseMask (_ref) {\n  var mask = _ref.mask,\n      maskPlaceholder = _ref.maskPlaceholder;\n  var permanents = [];\n\n  if (!mask) {\n    return {\n      maskPlaceholder: null,\n      mask: null,\n      prefix: null,\n      lastEditablePosition: null,\n      permanents: []\n    };\n  }\n\n  if (typeof mask === \"string\") {\n    var isPermanent = false;\n    var parsedMaskString = \"\";\n    mask.split(\"\").forEach(function (character) {\n      if (!isPermanent && character === \"\\\\\") {\n        isPermanent = true;\n      } else {\n        if (isPermanent || !defaultFormatChars[character]) {\n          permanents.push(parsedMaskString.length);\n        }\n\n        parsedMaskString += character;\n        isPermanent = false;\n      }\n    });\n    mask = parsedMaskString.split(\"\").map(function (character, index) {\n      if (permanents.indexOf(index) === -1) {\n        return defaultFormatChars[character];\n      }\n\n      return character;\n    });\n  } else {\n    mask.forEach(function (character, index) {\n      if (typeof character === \"string\") {\n        permanents.push(index);\n      }\n    });\n  }\n\n  if (maskPlaceholder) {\n    if (maskPlaceholder.length === 1) {\n      maskPlaceholder = mask.map(function (character, index) {\n        if (permanents.indexOf(index) !== -1) {\n          return character;\n        }\n\n        return maskPlaceholder;\n      });\n    } else {\n      maskPlaceholder = maskPlaceholder.split(\"\");\n    }\n\n    permanents.forEach(function (position) {\n      maskPlaceholder[position] = mask[position];\n    });\n    maskPlaceholder = maskPlaceholder.join(\"\");\n  }\n\n  var prefix = permanents.filter(function (position, index) {\n    return position === index;\n  }).map(function (position) {\n    return mask[position];\n  }).join(\"\");\n  var lastEditablePosition = mask.length - 1;\n\n  while (permanents.indexOf(lastEditablePosition) !== -1) {\n    lastEditablePosition--;\n  }\n\n  return {\n    maskPlaceholder: maskPlaceholder,\n    prefix: prefix,\n    mask: mask,\n    lastEditablePosition: lastEditablePosition,\n    permanents: permanents\n  };\n}\n\n/* eslint no-use-before-define: [\"error\", { functions: false }] */\n\nvar MaskUtils = function MaskUtils(options) {\n  var _this = this;\n\n  this.isCharacterAllowedAtPosition = function (character, position) {\n    var maskPlaceholder = _this.maskOptions.maskPlaceholder;\n\n    if (_this.isCharacterFillingPosition(character, position)) {\n      return true;\n    }\n\n    if (!maskPlaceholder) {\n      return false;\n    }\n\n    return maskPlaceholder[position] === character;\n  };\n\n  this.isCharacterFillingPosition = function (character, position) {\n    var mask = _this.maskOptions.mask;\n\n    if (!character || position >= mask.length) {\n      return false;\n    }\n\n    if (!_this.isPositionEditable(position)) {\n      return mask[position] === character;\n    }\n\n    var charRule = mask[position];\n    return new RegExp(charRule).test(character);\n  };\n\n  this.isPositionEditable = function (position) {\n    var _this$maskOptions = _this.maskOptions,\n        mask = _this$maskOptions.mask,\n        permanents = _this$maskOptions.permanents;\n    return position < mask.length && permanents.indexOf(position) === -1;\n  };\n\n  this.isValueEmpty = function (value) {\n    return value.split(\"\").every(function (character, position) {\n      return !_this.isPositionEditable(position) || !_this.isCharacterFillingPosition(character, position);\n    });\n  };\n\n  this.isValueFilled = function (value) {\n    return _this.getFilledLength(value) === _this.maskOptions.lastEditablePosition + 1;\n  };\n\n  this.getDefaultSelectionForValue = function (value) {\n    var filledLength = _this.getFilledLength(value);\n\n    var cursorPosition = _this.getRightEditablePosition(filledLength);\n\n    return {\n      start: cursorPosition,\n      end: cursorPosition\n    };\n  };\n\n  this.getFilledLength = function (value) {\n    var characters = value.split(\"\");\n    var lastFilledIndex = findLastIndex(characters, function (character, position) {\n      return _this.isPositionEditable(position) && _this.isCharacterFillingPosition(character, position);\n    });\n    return lastFilledIndex + 1;\n  };\n\n  this.getStringFillingLengthAtPosition = function (string, position) {\n    var characters = string.split(\"\");\n    var insertedValue = characters.reduce(function (value, character) {\n      return _this.insertCharacterAtPosition(value, character, value.length);\n    }, repeat(\" \", position));\n    return insertedValue.length - position;\n  };\n\n  this.getLeftEditablePosition = function (position) {\n    for (var i = position; i >= 0; i--) {\n      if (_this.isPositionEditable(i)) {\n        return i;\n      }\n    }\n\n    return null;\n  };\n\n  this.getRightEditablePosition = function (position) {\n    var mask = _this.maskOptions.mask;\n\n    for (var i = position; i < mask.length; i++) {\n      if (_this.isPositionEditable(i)) {\n        return i;\n      }\n    }\n\n    return null;\n  };\n\n  this.formatValue = function (value) {\n    var _this$maskOptions2 = _this.maskOptions,\n        maskPlaceholder = _this$maskOptions2.maskPlaceholder,\n        mask = _this$maskOptions2.mask;\n\n    if (!maskPlaceholder) {\n      value = _this.insertStringAtPosition(\"\", value, 0);\n\n      while (value.length < mask.length && !_this.isPositionEditable(value.length)) {\n        value += mask[value.length];\n      }\n\n      return value;\n    }\n\n    return _this.insertStringAtPosition(maskPlaceholder, value, 0);\n  };\n\n  this.clearRange = function (value, start, len) {\n    if (!len) {\n      return value;\n    }\n\n    var end = start + len;\n    var _this$maskOptions3 = _this.maskOptions,\n        maskPlaceholder = _this$maskOptions3.maskPlaceholder,\n        mask = _this$maskOptions3.mask;\n    var clearedValue = value.split(\"\").map(function (character, i) {\n      var isEditable = _this.isPositionEditable(i);\n\n      if (!maskPlaceholder && i >= end && !isEditable) {\n        return \"\";\n      }\n\n      if (i < start || i >= end) {\n        return character;\n      }\n\n      if (!isEditable) {\n        return mask[i];\n      }\n\n      if (maskPlaceholder) {\n        return maskPlaceholder[i];\n      }\n\n      return \"\";\n    }).join(\"\");\n    return _this.formatValue(clearedValue);\n  };\n\n  this.insertCharacterAtPosition = function (value, character, position) {\n    var _this$maskOptions4 = _this.maskOptions,\n        mask = _this$maskOptions4.mask,\n        maskPlaceholder = _this$maskOptions4.maskPlaceholder;\n\n    if (position >= mask.length) {\n      return value;\n    }\n\n    var isAllowed = _this.isCharacterAllowedAtPosition(character, position);\n\n    var isEditable = _this.isPositionEditable(position);\n\n    var nextEditablePosition = _this.getRightEditablePosition(position);\n\n    var isNextPlaceholder = maskPlaceholder && nextEditablePosition ? character === maskPlaceholder[nextEditablePosition] : null;\n    var valueBefore = value.slice(0, position);\n\n    if (isAllowed || !isEditable) {\n      var insertedCharacter = isAllowed ? character : mask[position];\n      value = valueBefore + insertedCharacter;\n    }\n\n    if (!isAllowed && !isEditable && !isNextPlaceholder) {\n      value = _this.insertCharacterAtPosition(value, character, position + 1);\n    }\n\n    return value;\n  };\n\n  this.insertStringAtPosition = function (value, string, position) {\n    var _this$maskOptions5 = _this.maskOptions,\n        mask = _this$maskOptions5.mask,\n        maskPlaceholder = _this$maskOptions5.maskPlaceholder;\n\n    if (!string || position >= mask.length) {\n      return value;\n    }\n\n    var characters = string.split(\"\");\n    var isFixedLength = _this.isValueFilled(value) || !!maskPlaceholder;\n    var valueAfter = value.slice(position);\n    value = characters.reduce(function (value, character) {\n      return _this.insertCharacterAtPosition(value, character, value.length);\n    }, value.slice(0, position));\n\n    if (isFixedLength) {\n      value += valueAfter.slice(value.length - position);\n    } else if (_this.isValueFilled(value)) {\n      value += mask.slice(value.length).join(\"\");\n    } else {\n      var editableCharactersAfter = valueAfter.split(\"\").filter(function (character, i) {\n        return _this.isPositionEditable(position + i);\n      });\n      value = editableCharactersAfter.reduce(function (value, character) {\n        var nextEditablePosition = _this.getRightEditablePosition(value.length);\n\n        if (nextEditablePosition === null) {\n          return value;\n        }\n\n        if (!_this.isPositionEditable(value.length)) {\n          value += mask.slice(value.length, nextEditablePosition).join(\"\");\n        }\n\n        return _this.insertCharacterAtPosition(value, character, value.length);\n      }, value);\n    }\n\n    return value;\n  };\n\n  this.processChange = function (currentState, previousState) {\n    var _this$maskOptions6 = _this.maskOptions,\n        mask = _this$maskOptions6.mask,\n        prefix = _this$maskOptions6.prefix,\n        lastEditablePosition = _this$maskOptions6.lastEditablePosition;\n    var value = currentState.value,\n        selection = currentState.selection;\n    var previousValue = previousState.value;\n    var previousSelection = previousState.selection;\n    var newValue = value;\n    var enteredString = \"\";\n    var formattedEnteredStringLength = 0;\n    var removedLength = 0;\n    var cursorPosition = Math.min(previousSelection.start, selection.start);\n\n    if (selection.end > previousSelection.start) {\n      enteredString = newValue.slice(previousSelection.start, selection.end);\n      formattedEnteredStringLength = _this.getStringFillingLengthAtPosition(enteredString, cursorPosition);\n\n      if (!formattedEnteredStringLength) {\n        removedLength = 0;\n      } else {\n        removedLength = previousSelection.length;\n      }\n    } else if (newValue.length < previousValue.length) {\n      removedLength = previousValue.length - newValue.length;\n    }\n\n    newValue = previousValue;\n\n    if (removedLength) {\n      if (removedLength === 1 && !previousSelection.length) {\n        var deleteFromRight = previousSelection.start === selection.start;\n        cursorPosition = deleteFromRight ? _this.getRightEditablePosition(selection.start) : _this.getLeftEditablePosition(selection.start);\n      }\n\n      newValue = _this.clearRange(newValue, cursorPosition, removedLength);\n    }\n\n    newValue = _this.insertStringAtPosition(newValue, enteredString, cursorPosition);\n    cursorPosition += formattedEnteredStringLength;\n\n    if (cursorPosition >= mask.length) {\n      cursorPosition = mask.length;\n    } else if (cursorPosition < prefix.length && !formattedEnteredStringLength) {\n      cursorPosition = prefix.length;\n    } else if (cursorPosition >= prefix.length && cursorPosition < lastEditablePosition && formattedEnteredStringLength) {\n      cursorPosition = _this.getRightEditablePosition(cursorPosition);\n    }\n\n    newValue = _this.formatValue(newValue);\n    return {\n      value: newValue,\n      enteredString: enteredString,\n      selection: {\n        start: cursorPosition,\n        end: cursorPosition\n      }\n    };\n  };\n\n  this.maskOptions = parseMask(options);\n};\n\nvar InputMaskChildrenWrapper =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inheritsLoose(InputMaskChildrenWrapper, _React$Component);\n\n  function InputMaskChildrenWrapper() {\n    return _React$Component.apply(this, arguments) || this;\n  }\n\n  var _proto = InputMaskChildrenWrapper.prototype;\n\n  _proto.render = function render() {\n    // eslint-disable-next-line react/prop-types\n    var _this$props = this.props,\n        children = _this$props.children,\n        props = _objectWithoutPropertiesLoose(_this$props, [\"children\"]);\n\n    return React__default.cloneElement(children, props);\n  };\n\n  return InputMaskChildrenWrapper;\n}(React__default.Component);\n\nvar InputMask = React.forwardRef(function InputMask(props, forwardedRef) {\n  var alwaysShowMask = props.alwaysShowMask,\n      children = props.children,\n      mask = props.mask,\n      maskPlaceholder = props.maskPlaceholder,\n      beforeMaskedStateChange = props.beforeMaskedStateChange,\n      restProps = _objectWithoutPropertiesLoose(props, [\"alwaysShowMask\", \"children\", \"mask\", \"maskPlaceholder\", \"beforeMaskedStateChange\"]);\n\n  validateMaxLength(props);\n  validateMaskPlaceholder(props);\n  var maskUtils = new MaskUtils({\n    mask: mask,\n    maskPlaceholder: maskPlaceholder\n  });\n  var isMasked = !!mask;\n  var isEditable = !restProps.disabled && !restProps.readOnly;\n  var isControlled = props.value !== null && props.value !== undefined;\n  var previousIsMasked = usePrevious(isMasked);\n  var initialValue = toString((isControlled ? props.value : props.defaultValue) || \"\");\n\n  var _useInputState = useInputState(initialValue, isMasked),\n      inputRef = _useInputState.inputRef,\n      getInputState = _useInputState.getInputState,\n      setInputState = _useInputState.setInputState,\n      getLastInputState = _useInputState.getLastInputState;\n\n  var getInputElement = useInputElement(inputRef);\n\n  function onChange(event) {\n    var currentState = getInputState();\n    var previousState = getLastInputState();\n    var newInputState = maskUtils.processChange(currentState, previousState);\n\n    if (beforeMaskedStateChange) {\n      newInputState = beforeMaskedStateChange({\n        currentState: currentState,\n        previousState: previousState,\n        nextState: newInputState\n      });\n    }\n\n    setInputState(newInputState);\n\n    if (props.onChange) {\n      props.onChange(event);\n    }\n  }\n\n  function onFocus(event) {\n    // If autoFocus property is set, focus event fires before the ref handler gets called\n    inputRef.current = event.target;\n    var currentValue = getInputState().value;\n\n    if (isMasked && !maskUtils.isValueFilled(currentValue)) {\n      var newValue = maskUtils.formatValue(currentValue);\n      var newSelection = maskUtils.getDefaultSelectionForValue(newValue);\n      var newInputState = {\n        value: newValue,\n        selection: newSelection\n      };\n\n      if (beforeMaskedStateChange) {\n        newInputState = beforeMaskedStateChange({\n          currentState: getInputState(),\n          nextState: newInputState\n        });\n        newValue = newInputState.value;\n        newSelection = newInputState.selection;\n      }\n\n      setInputState(newInputState);\n\n      if (newValue !== currentValue && props.onChange) {\n        props.onChange(event);\n      } // Chrome resets selection after focus event,\n      // so we want to restore it later\n\n\n      defer(function () {\n        setInputState(getLastInputState());\n      });\n    }\n\n    if (props.onFocus) {\n      props.onFocus(event);\n    }\n  }\n\n  function onBlur(event) {\n    var currentValue = getInputState().value;\n    var lastValue = getLastInputState().value;\n\n    if (isMasked && !alwaysShowMask && maskUtils.isValueEmpty(lastValue)) {\n      var newValue = \"\";\n      var newInputState = {\n        value: newValue,\n        selection: {\n          start: null,\n          end: null\n        }\n      };\n\n      if (beforeMaskedStateChange) {\n        newInputState = beforeMaskedStateChange({\n          currentState: getInputState(),\n          nextState: newInputState\n        });\n        newValue = newInputState.value;\n      }\n\n      setInputState(newInputState);\n\n      if (newValue !== currentValue && props.onChange) {\n        props.onChange(event);\n      }\n    }\n\n    if (props.onBlur) {\n      props.onBlur(event);\n    }\n  } // Tiny unintentional mouse movements can break cursor\n  // position on focus, so we have to restore it in that case\n  //\n  // https://github.com/sanniassin/react-input-mask/issues/108\n\n\n  function onMouseDown(event) {\n    var input = getInputElement();\n\n    var _getInputState = getInputState(),\n        value = _getInputState.value;\n\n    var inputDocument = getElementDocument(input);\n\n    if (!isInputFocused(input) && !maskUtils.isValueFilled(value)) {\n      var mouseDownX = event.clientX;\n      var mouseDownY = event.clientY;\n      var mouseDownTime = new Date().getTime();\n\n      var mouseUpHandler = function mouseUpHandler(mouseUpEvent) {\n        inputDocument.removeEventListener(\"mouseup\", mouseUpHandler);\n\n        if (!isInputFocused(input)) {\n          return;\n        }\n\n        var deltaX = Math.abs(mouseUpEvent.clientX - mouseDownX);\n        var deltaY = Math.abs(mouseUpEvent.clientY - mouseDownY);\n        var axisDelta = Math.max(deltaX, deltaY);\n        var timeDelta = new Date().getTime() - mouseDownTime;\n\n        if (axisDelta <= 10 && timeDelta <= 200 || axisDelta <= 5 && timeDelta <= 300) {\n          var _lastState = getLastInputState();\n\n          var newSelection = maskUtils.getDefaultSelectionForValue(_lastState.value);\n\n          var newState = _extends({}, _lastState, {\n            selection: newSelection\n          });\n\n          setInputState(newState);\n        }\n      };\n\n      inputDocument.addEventListener(\"mouseup\", mouseUpHandler);\n    }\n\n    if (props.onMouseDown) {\n      props.onMouseDown(event);\n    }\n  } // For controlled inputs we want to provide properly formatted\n  // value prop\n\n\n  if (isMasked && isControlled) {\n    var input = getInputElement();\n    var isFocused = input && isInputFocused(input);\n    var newValue = isFocused || alwaysShowMask || props.value ? maskUtils.formatValue(props.value) : props.value;\n\n    if (beforeMaskedStateChange) {\n      newValue = beforeMaskedStateChange({\n        nextState: {\n          value: newValue,\n          selection: {\n            start: null,\n            end: null\n          }\n        }\n      }).value;\n    }\n\n    setInputState(_extends({}, getLastInputState(), {\n      value: newValue\n    }));\n  }\n\n  var lastState = getLastInputState();\n  var lastSelection = lastState.selection;\n  var lastValue = lastState.value;\n  React.useLayoutEffect(function () {\n    if (!isMasked) {\n      return;\n    }\n\n    var input = getInputElement();\n    var isFocused = isInputFocused(input);\n    var previousSelection = lastSelection;\n    var currentState = getInputState();\n\n    var newInputState = _extends({}, currentState); // Update value for uncontrolled inputs to make sure\n    // it's always in sync with mask props\n\n\n    if (!isControlled) {\n      var currentValue = currentState.value;\n      var formattedValue = maskUtils.formatValue(currentValue);\n      var isValueEmpty = maskUtils.isValueEmpty(formattedValue);\n      var shouldFormatValue = !isValueEmpty || isFocused || alwaysShowMask;\n\n      if (shouldFormatValue) {\n        newInputState.value = formattedValue;\n      } else if (isValueEmpty && !isFocused) {\n        newInputState.value = \"\";\n      }\n    }\n\n    if (isFocused && !previousIsMasked) {\n      // Adjust selection if input got masked while being focused\n      newInputState.selection = maskUtils.getDefaultSelectionForValue(newInputState.value);\n    } else if (isControlled && isFocused && previousSelection) {\n      // Restore cursor position if value has changed outside change event\n      if (previousSelection.start !== null && previousSelection.end !== null) {\n        newInputState.selection = previousSelection;\n      }\n    }\n\n    if (beforeMaskedStateChange) {\n      newInputState = beforeMaskedStateChange({\n        currentState: currentState,\n        nextState: newInputState\n      });\n    }\n\n    setInputState(newInputState);\n  });\n\n  var inputProps = _extends({}, restProps, {\n    onFocus: onFocus,\n    onBlur: onBlur,\n    onChange: isMasked && isEditable ? onChange : props.onChange,\n    onMouseDown: isMasked && isEditable ? onMouseDown : props.onMouseDown,\n    ref: function ref(_ref) {\n      inputRef.current = reactDom.findDOMNode(_ref);\n\n      if (isFunction(forwardedRef)) {\n        forwardedRef(_ref);\n      } else if (forwardedRef !== null && typeof forwardedRef === \"object\") {\n        forwardedRef.current = _ref;\n      }\n    },\n    value: isMasked && isControlled ? lastValue : props.value\n  });\n\n  if (children) {\n    validateChildren(props, children); // We wrap children into a class component to be able to find\n    // their input element using findDOMNode\n\n    return React__default.createElement(InputMaskChildrenWrapper, inputProps, children);\n  }\n\n  return React__default.createElement(\"input\", inputProps);\n});\nInputMask.displayName = \"InputMask\";\nInputMask.defaultProps = {\n  alwaysShowMask: false,\n  maskPlaceholder: \"_\"\n};\nInputMask.propTypes = {\n  alwaysShowMask: PropTypes.bool,\n  beforeMaskedStateChange: PropTypes.func,\n  children: PropTypes.element,\n  mask: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.instanceOf(RegExp)]))]),\n  maskPlaceholder: PropTypes.string,\n  onFocus: PropTypes.func,\n  onBlur: PropTypes.func,\n  onChange: PropTypes.func,\n  onMouseDown: PropTypes.func\n};\n\nmodule.exports = InputMask;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtaW5wdXQtbWFzay9saWIvcmVhY3QtaW5wdXQtbWFzay5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixnQ0FBZ0M7O0FBRWhDLFlBQVksbUJBQU8sQ0FBQyx3R0FBTztBQUMzQjtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxnSEFBVztBQUNsQyxnQ0FBZ0MsbUJBQU8sQ0FBQyw0REFBWTtBQUNwRCxnQ0FBZ0MsbUJBQU8sQ0FBQyw4REFBVztBQUNuRCw4QkFBOEIsbUJBQU8sQ0FBQyx3REFBUzs7QUFFL0MscUNBQXFDLGlEQUFpRCxnQkFBZ0IsaUJBQWlCLE9BQU8sbUJBQW1CLDREQUE0RCw2REFBNkQsNENBQTRDOztBQUV0VDtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLE9BQU87QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsbUNBQW1DO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4REFBOEQ7O0FBRTlEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUUsS0FBcUMsK01BQStNLENBQU07QUFDNVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMkcsS0FBcUMsMk1BQTJNLENBQWdCO0FBQzNXO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDJCQUEyQixLQUFxQyx3SkFBd0osQ0FBZ0I7QUFDeE87O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLGtCQUFrQjs7QUFFOUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOzs7QUFHQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxvQ0FBb0M7QUFDcEM7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLDZCQUE2QjtBQUM3QjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsaUJBQWlCO0FBQ3BEOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRzs7QUFFSCw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQSx1Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BpZXJtb250Ly4vbm9kZV9tb2R1bGVzL3JlYWN0LWlucHV0LW1hc2svbGliL3JlYWN0LWlucHV0LW1hc2suZGV2ZWxvcG1lbnQuanM/ODBjMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdCAoZXgpIHsgcmV0dXJuIChleCAmJiAodHlwZW9mIGV4ID09PSAnb2JqZWN0JykgJiYgJ2RlZmF1bHQnIGluIGV4KSA/IGV4WydkZWZhdWx0J10gOiBleDsgfVxuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIFJlYWN0X19kZWZhdWx0ID0gX2ludGVyb3BEZWZhdWx0KFJlYWN0KTtcbnZhciByZWFjdERvbSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xudmFyIFByb3BUeXBlcyA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdwcm9wLXR5cGVzJykpO1xudmFyIGludmFyaWFudCA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdpbnZhcmlhbnQnKSk7XG52YXIgd2FybmluZyA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCd3YXJuaW5nJykpO1xuXG5mdW5jdGlvbiBfZGVmYXVsdHMyKG9iaiwgZGVmYXVsdHMpIHsgdmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhkZWZhdWx0cyk7IGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykgeyB2YXIga2V5ID0ga2V5c1tpXTsgdmFyIHZhbHVlID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihkZWZhdWx0cywga2V5KTsgaWYgKHZhbHVlICYmIHZhbHVlLmNvbmZpZ3VyYWJsZSAmJiBvYmpba2V5XSA9PT0gdW5kZWZpbmVkKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpOyB9IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG5cbiAgX2RlZmF1bHRzMihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBkZWZlcihmbikge1xuICByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKTtcbn1cbmZ1bmN0aW9uIGNhbmNlbERlZmVyKGRlZmVySWQpIHtcbiAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZGVmZXJJZCk7XG59XG5cbmZ1bmN0aW9uIHNldElucHV0U2VsZWN0aW9uKGlucHV0LCBzdGFydCwgZW5kKSB7XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHN0YXJ0O1xuICB9XG5cbiAgaW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2Uoc3RhcnQsIGVuZCk7XG59XG5mdW5jdGlvbiBnZXRJbnB1dFNlbGVjdGlvbihpbnB1dCkge1xuICB2YXIgc3RhcnQgPSBpbnB1dC5zZWxlY3Rpb25TdGFydDtcbiAgdmFyIGVuZCA9IGlucHV0LnNlbGVjdGlvbkVuZDtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnQsXG4gICAgZW5kOiBlbmQsXG4gICAgbGVuZ3RoOiBlbmQgLSBzdGFydFxuICB9O1xufVxuZnVuY3Rpb24gaXNJbnB1dEZvY3VzZWQoaW5wdXQpIHtcbiAgdmFyIGlucHV0RG9jdW1lbnQgPSBpbnB1dC5vd25lckRvY3VtZW50O1xuICByZXR1cm4gaW5wdXREb2N1bWVudC5oYXNGb2N1cygpICYmIGlucHV0RG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gaW5wdXQ7XG59XG5cbi8vIEVsZW1lbnQncyB3aW5kb3cgbWF5IGRpZmZlciBmcm9tIHRoZSBvbmUgd2l0aGluIFJlYWN0IGluc3RhbmNlXG4vLyBpZiBlbGVtZW50IHJlbmRlcmVkIHdpdGhpbiBpZnJhbWUuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Nhbm5pYXNzaW4vcmVhY3QtaW5wdXQtbWFzay9pc3N1ZXMvMTgyXG5mdW5jdGlvbiBnZXRFbGVtZW50RG9jdW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogZWxlbWVudC5vd25lckRvY3VtZW50O1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudFdpbmRvdyhlbGVtZW50KSB7XG4gIHZhciBfZ2V0RWxlbWVudERvY3VtZW50O1xuXG4gIHJldHVybiAoX2dldEVsZW1lbnREb2N1bWVudCA9IGdldEVsZW1lbnREb2N1bWVudChlbGVtZW50KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9nZXRFbGVtZW50RG9jdW1lbnQuZGVmYXVsdFZpZXc7XG59XG5mdW5jdGlvbiBpc0RPTUVsZW1lbnQoZWxlbWVudCkge1xuICB2YXIgZWxlbWVudFdpbmRvdyA9IGdldEVsZW1lbnRXaW5kb3coZWxlbWVudCk7XG4gIHJldHVybiAhIWVsZW1lbnRXaW5kb3cgJiYgZWxlbWVudCBpbnN0YW5jZW9mIGVsZW1lbnRXaW5kb3cuSFRNTEVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGZpbmRMYXN0SW5kZXgoYXJyYXksIHByZWRpY2F0ZSkge1xuICBmb3IgKHZhciBpID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgeCA9IGFycmF5W2ldO1xuXG4gICAgaWYgKHByZWRpY2F0ZSh4LCBpKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gcmVwZWF0KHN0cmluZywgbikge1xuICBpZiAobiA9PT0gdm9pZCAwKSB7XG4gICAgbiA9IDE7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gXCJcIjtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIHJlc3VsdCArPSBzdHJpbmc7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdXNlSW5wdXRFbGVtZW50KGlucHV0UmVmKSB7XG4gIHJldHVybiBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlucHV0ID0gaW5wdXRSZWYuY3VycmVudDtcbiAgICB2YXIgaXNET01Ob2RlID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpc0RPTUVsZW1lbnQoaW5wdXQpOyAvLyB3b3JrYXJvdW5kIGZvciByZWFjdC10ZXN0LXJlbmRlcmVyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Nhbm5pYXNzaW4vcmVhY3QtaW5wdXQtbWFzay9pc3N1ZXMvMTQ3XG5cbiAgICBpZiAoIWlucHV0IHx8ICFpc0RPTU5vZGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChpbnB1dC5ub2RlTmFtZSAhPT0gXCJJTlBVVFwiKSB7XG4gICAgICBpbnB1dCA9IGlucHV0LnF1ZXJ5U2VsZWN0b3IoXCJpbnB1dFwiKTtcbiAgICB9XG5cbiAgICBpZiAoIWlucHV0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZWFjdC1pbnB1dC1tYXNrOiBpbnB1dENvbXBvbmVudCBkb2Vzbid0IGNvbnRhaW4gaW5wdXQgbm9kZVwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5wdXQ7XG4gIH0sIFtpbnB1dFJlZl0pO1xufVxuXG5mdW5jdGlvbiB1c2VEZWZlckxvb3AoY2FsbGJhY2spIHtcbiAgdmFyIGRlZmVySWRSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIHZhciBydW5Mb29wID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIC8vIElmIHRoZXJlIGFyZSBzaW11bGF0ZWQgZm9jdXMgZXZlbnRzLCBydW5Mb29wIGNvdWxkIGJlXG4gICAgLy8gY2FsbGVkIG11bHRpcGxlIHRpbWVzIHdpdGhvdXQgYmx1ciBvciByZS1yZW5kZXJcbiAgICBpZiAoZGVmZXJJZFJlZi5jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9vcCgpIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgICBkZWZlcklkUmVmLmN1cnJlbnQgPSBkZWZlcihsb29wKTtcbiAgICB9XG5cbiAgICBsb29wKCk7XG4gIH0sIFtjYWxsYmFja10pO1xuICB2YXIgc3RvcExvb3AgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgY2FuY2VsRGVmZXIoZGVmZXJJZFJlZi5jdXJyZW50KTtcbiAgICBkZWZlcklkUmVmLmN1cnJlbnQgPSBudWxsO1xuICB9LCBbXSk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGRlZmVySWRSZWYuY3VycmVudCkge1xuICAgICAgc3RvcExvb3AoKTtcbiAgICAgIHJ1bkxvb3AoKTtcbiAgICB9XG4gIH0sIFtydW5Mb29wLCBzdG9wTG9vcF0pO1xuICBSZWFjdC51c2VFZmZlY3QoY2FuY2VsRGVmZXIsIFtdKTtcbiAgcmV0dXJuIFtydW5Mb29wLCBzdG9wTG9vcF07XG59XG5cbmZ1bmN0aW9uIHVzZVNlbGVjdGlvbihpbnB1dFJlZiwgaXNNYXNrZWQpIHtcbiAgdmFyIHNlbGVjdGlvblJlZiA9IFJlYWN0LnVzZVJlZih7XG4gICAgc3RhcnQ6IG51bGwsXG4gICAgZW5kOiBudWxsXG4gIH0pO1xuICB2YXIgZ2V0SW5wdXRFbGVtZW50ID0gdXNlSW5wdXRFbGVtZW50KGlucHV0UmVmKTtcbiAgdmFyIGdldFNlbGVjdGlvbiA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5wdXQgPSBnZXRJbnB1dEVsZW1lbnQoKTtcbiAgICByZXR1cm4gZ2V0SW5wdXRTZWxlY3Rpb24oaW5wdXQpO1xuICB9LCBbZ2V0SW5wdXRFbGVtZW50XSk7XG4gIHZhciBnZXRMYXN0U2VsZWN0aW9uID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzZWxlY3Rpb25SZWYuY3VycmVudDtcbiAgfSwgW10pO1xuICB2YXIgc2V0U2VsZWN0aW9uID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgIHZhciBpbnB1dCA9IGdldElucHV0RWxlbWVudCgpOyAvLyBEb24ndCBjaGFuZ2Ugc2VsZWN0aW9uIG9uIHVuZm9jdXNlZCBpbnB1dFxuICAgIC8vIGJlY2F1c2UgU2FmYXJpIHNldHMgZm9jdXMgb24gc2VsZWN0aW9uIGNoYW5nZSAoIzE1NClcblxuICAgIGlmICghaW5wdXQgfHwgIWlzSW5wdXRGb2N1c2VkKGlucHV0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNldElucHV0U2VsZWN0aW9uKGlucHV0LCBzZWxlY3Rpb24uc3RhcnQsIHNlbGVjdGlvbi5lbmQpOyAvLyBVc2UgYWN0dWFsIHNlbGVjdGlvbiBpbiBjYXNlIHRoZSByZXF1ZXN0ZWQgb25lIHdhcyBvdXQgb2YgcmFuZ2VcblxuICAgIHNlbGVjdGlvblJlZi5jdXJyZW50ID0gZ2V0U2VsZWN0aW9uKCk7XG4gIH0sIFtnZXRJbnB1dEVsZW1lbnQsIGdldFNlbGVjdGlvbl0pO1xuICB2YXIgc2VsZWN0aW9uTG9vcCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICBzZWxlY3Rpb25SZWYuY3VycmVudCA9IGdldFNlbGVjdGlvbigpO1xuICB9LCBbZ2V0U2VsZWN0aW9uXSk7XG5cbiAgdmFyIF91c2VEZWZlckxvb3AgPSB1c2VEZWZlckxvb3Aoc2VsZWN0aW9uTG9vcCksXG4gICAgICBydW5TZWxlY3Rpb25Mb29wID0gX3VzZURlZmVyTG9vcFswXSxcbiAgICAgIHN0b3BTZWxlY3Rpb25Mb29wID0gX3VzZURlZmVyTG9vcFsxXTtcblxuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICghaXNNYXNrZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaW5wdXQgPSBnZXRJbnB1dEVsZW1lbnQoKTtcbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgcnVuU2VsZWN0aW9uTG9vcCk7XG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgc3RvcFNlbGVjdGlvbkxvb3ApO1xuXG4gICAgaWYgKGlzSW5wdXRGb2N1c2VkKGlucHV0KSkge1xuICAgICAgcnVuU2VsZWN0aW9uTG9vcCgpO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgcnVuU2VsZWN0aW9uTG9vcCk7XG4gICAgICBpbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCBzdG9wU2VsZWN0aW9uTG9vcCk7XG4gICAgICBzdG9wU2VsZWN0aW9uTG9vcCgpO1xuICAgIH07XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGdldFNlbGVjdGlvbjogZ2V0U2VsZWN0aW9uLFxuICAgIGdldExhc3RTZWxlY3Rpb246IGdldExhc3RTZWxlY3Rpb24sXG4gICAgc2V0U2VsZWN0aW9uOiBzZXRTZWxlY3Rpb25cbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlVmFsdWUoaW5wdXRSZWYsIGluaXRpYWxWYWx1ZSkge1xuICB2YXIgZ2V0SW5wdXRFbGVtZW50ID0gdXNlSW5wdXRFbGVtZW50KGlucHV0UmVmKTtcbiAgdmFyIHZhbHVlUmVmID0gUmVhY3QudXNlUmVmKGluaXRpYWxWYWx1ZSk7XG4gIHZhciBnZXRWYWx1ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5wdXQgPSBnZXRJbnB1dEVsZW1lbnQoKTtcbiAgICByZXR1cm4gaW5wdXQudmFsdWU7XG4gIH0sIFtnZXRJbnB1dEVsZW1lbnRdKTtcbiAgdmFyIGdldExhc3RWYWx1ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdmFsdWVSZWYuY3VycmVudDtcbiAgfSwgW10pO1xuICB2YXIgc2V0VmFsdWUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICB2YWx1ZVJlZi5jdXJyZW50ID0gbmV3VmFsdWU7XG4gICAgdmFyIGlucHV0ID0gZ2V0SW5wdXRFbGVtZW50KCk7XG5cbiAgICBpZiAoaW5wdXQpIHtcbiAgICAgIGlucHV0LnZhbHVlID0gbmV3VmFsdWU7XG4gICAgfVxuICB9LCBbZ2V0SW5wdXRFbGVtZW50XSk7XG4gIHJldHVybiB7XG4gICAgZ2V0VmFsdWU6IGdldFZhbHVlLFxuICAgIGdldExhc3RWYWx1ZTogZ2V0TGFzdFZhbHVlLFxuICAgIHNldFZhbHVlOiBzZXRWYWx1ZVxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VJbnB1dFN0YXRlKGluaXRpYWxWYWx1ZSwgaXNNYXNrZWQpIHtcbiAgdmFyIGlucHV0UmVmID0gUmVhY3QudXNlUmVmKCk7XG5cbiAgdmFyIF91c2VTZWxlY3Rpb24gPSB1c2VTZWxlY3Rpb24oaW5wdXRSZWYsIGlzTWFza2VkKSxcbiAgICAgIGdldFNlbGVjdGlvbiA9IF91c2VTZWxlY3Rpb24uZ2V0U2VsZWN0aW9uLFxuICAgICAgZ2V0TGFzdFNlbGVjdGlvbiA9IF91c2VTZWxlY3Rpb24uZ2V0TGFzdFNlbGVjdGlvbixcbiAgICAgIHNldFNlbGVjdGlvbiA9IF91c2VTZWxlY3Rpb24uc2V0U2VsZWN0aW9uO1xuXG4gIHZhciBfdXNlVmFsdWUgPSB1c2VWYWx1ZShpbnB1dFJlZiwgaW5pdGlhbFZhbHVlKSxcbiAgICAgIGdldFZhbHVlID0gX3VzZVZhbHVlLmdldFZhbHVlLFxuICAgICAgZ2V0TGFzdFZhbHVlID0gX3VzZVZhbHVlLmdldExhc3RWYWx1ZSxcbiAgICAgIHNldFZhbHVlID0gX3VzZVZhbHVlLnNldFZhbHVlO1xuXG4gIGZ1bmN0aW9uIGdldExhc3RJbnB1dFN0YXRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogZ2V0TGFzdFZhbHVlKCksXG4gICAgICBzZWxlY3Rpb246IGdldExhc3RTZWxlY3Rpb24oKVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJbnB1dFN0YXRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogZ2V0VmFsdWUoKSxcbiAgICAgIHNlbGVjdGlvbjogZ2V0U2VsZWN0aW9uKClcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0SW5wdXRTdGF0ZShfcmVmKSB7XG4gICAgdmFyIHZhbHVlID0gX3JlZi52YWx1ZSxcbiAgICAgICAgc2VsZWN0aW9uID0gX3JlZi5zZWxlY3Rpb247XG4gICAgc2V0VmFsdWUodmFsdWUpO1xuICAgIHNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBpbnB1dFJlZjogaW5wdXRSZWYsXG4gICAgZ2V0SW5wdXRTdGF0ZTogZ2V0SW5wdXRTdGF0ZSxcbiAgICBnZXRMYXN0SW5wdXRTdGF0ZTogZ2V0TGFzdElucHV0U3RhdGUsXG4gICAgc2V0SW5wdXRTdGF0ZTogc2V0SW5wdXRTdGF0ZVxuICB9O1xufVxuZnVuY3Rpb24gdXNlUHJldmlvdXModmFsdWUpIHtcbiAgdmFyIHJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVmLmN1cnJlbnQ7XG59XG5cbnZhciBDT05UUk9MTEVEX1BST1BTID0gW1wiZGlzYWJsZWRcIiwgXCJvbkJsdXJcIiwgXCJvbkNoYW5nZVwiLCBcIm9uRm9jdXNcIiwgXCJvbk1vdXNlRG93blwiLCBcInJlYWRPbmx5XCIsIFwidmFsdWVcIl07XG52YXIgZGVmYXVsdEZvcm1hdENoYXJzID0ge1xuICBcIjlcIjogL1swLTldLyxcbiAgYTogL1tBLVphLXpdLyxcbiAgXCIqXCI6IC9bQS1aYS16MC05XS9cbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTWF4TGVuZ3RoKHByb3BzKSB7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoIXByb3BzLm1heExlbmd0aCB8fCAhcHJvcHMubWFzaywgXCJyZWFjdC1pbnB1dC1tYXNrOiBtYXhMZW5ndGggcHJvcGVydHkgc2hvdWxkbid0IGJlIHBhc3NlZCB0byB0aGUgbWFza2VkIGlucHV0LiBJdCBicmVha3MgbWFza2luZyBhbmQgdW5uZWNlc3NhcnkgYmVjYXVzZSBsZW5ndGggaXMgbGltaXRlZCBieSB0aGUgbWFzayBsZW5ndGguXCIpIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVNYXNrUGxhY2Vob2xkZXIocHJvcHMpIHtcbiAgdmFyIG1hc2sgPSBwcm9wcy5tYXNrLFxuICAgICAgbWFza1BsYWNlaG9sZGVyID0gcHJvcHMubWFza1BsYWNlaG9sZGVyO1xuICAhKCFtYXNrIHx8ICFtYXNrUGxhY2Vob2xkZXIgfHwgbWFza1BsYWNlaG9sZGVyLmxlbmd0aCA9PT0gMSB8fCBtYXNrUGxhY2Vob2xkZXIubGVuZ3RoID09PSBtYXNrLmxlbmd0aCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwicmVhY3QtaW5wdXQtbWFzazogbWFza1BsYWNlaG9sZGVyIHNob3VsZCBlaXRoZXIgYmUgYSBzaW5nbGUgY2hhcmFjdGVyIG9yIGhhdmUgdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZSBtYXNrOlxcblwiICsgKFwibWFzazogXCIgKyBtYXNrICsgXCJcXG5cIikgKyAoXCJtYXNrUGxhY2Vob2xkZXI6IFwiICsgbWFza1BsYWNlaG9sZGVyKSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZHJlbihwcm9wcywgaW5wdXRFbGVtZW50KSB7XG4gIHZhciBjb25mbGljdFByb3BzID0gQ09OVFJPTExFRF9QUk9QUy5maWx0ZXIoZnVuY3Rpb24gKHByb3BJZCkge1xuICAgIHJldHVybiBpbnB1dEVsZW1lbnQucHJvcHNbcHJvcElkXSAhPSBudWxsICYmIGlucHV0RWxlbWVudC5wcm9wc1twcm9wSWRdICE9PSBwcm9wc1twcm9wSWRdO1xuICB9KTtcbiAgISFjb25mbGljdFByb3BzLmxlbmd0aCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJyZWFjdC1pbnB1dC1tYXNrOiB0aGUgZm9sbG93aW5nIHByb3BzIHNob3VsZCBiZSBwYXNzZWQgdG8gdGhlIElucHV0TWFzayBjb21wb25lbnQsIG5vdCB0byBjaGlsZHJlbjogXCIgKyBjb25mbGljdFByb3BzLmpvaW4oXCIsXCIpKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTWFzayAoX3JlZikge1xuICB2YXIgbWFzayA9IF9yZWYubWFzayxcbiAgICAgIG1hc2tQbGFjZWhvbGRlciA9IF9yZWYubWFza1BsYWNlaG9sZGVyO1xuICB2YXIgcGVybWFuZW50cyA9IFtdO1xuXG4gIGlmICghbWFzaykge1xuICAgIHJldHVybiB7XG4gICAgICBtYXNrUGxhY2Vob2xkZXI6IG51bGwsXG4gICAgICBtYXNrOiBudWxsLFxuICAgICAgcHJlZml4OiBudWxsLFxuICAgICAgbGFzdEVkaXRhYmxlUG9zaXRpb246IG51bGwsXG4gICAgICBwZXJtYW5lbnRzOiBbXVxuICAgIH07XG4gIH1cblxuICBpZiAodHlwZW9mIG1hc2sgPT09IFwic3RyaW5nXCIpIHtcbiAgICB2YXIgaXNQZXJtYW5lbnQgPSBmYWxzZTtcbiAgICB2YXIgcGFyc2VkTWFza1N0cmluZyA9IFwiXCI7XG4gICAgbWFzay5zcGxpdChcIlwiKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFyYWN0ZXIpIHtcbiAgICAgIGlmICghaXNQZXJtYW5lbnQgJiYgY2hhcmFjdGVyID09PSBcIlxcXFxcIikge1xuICAgICAgICBpc1Blcm1hbmVudCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNQZXJtYW5lbnQgfHwgIWRlZmF1bHRGb3JtYXRDaGFyc1tjaGFyYWN0ZXJdKSB7XG4gICAgICAgICAgcGVybWFuZW50cy5wdXNoKHBhcnNlZE1hc2tTdHJpbmcubGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnNlZE1hc2tTdHJpbmcgKz0gY2hhcmFjdGVyO1xuICAgICAgICBpc1Blcm1hbmVudCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG1hc2sgPSBwYXJzZWRNYXNrU3RyaW5nLnNwbGl0KFwiXCIpLm1hcChmdW5jdGlvbiAoY2hhcmFjdGVyLCBpbmRleCkge1xuICAgICAgaWYgKHBlcm1hbmVudHMuaW5kZXhPZihpbmRleCkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0Rm9ybWF0Q2hhcnNbY2hhcmFjdGVyXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYXJhY3RlcjtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBtYXNrLmZvckVhY2goZnVuY3Rpb24gKGNoYXJhY3RlciwgaW5kZXgpIHtcbiAgICAgIGlmICh0eXBlb2YgY2hhcmFjdGVyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHBlcm1hbmVudHMucHVzaChpbmRleCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAobWFza1BsYWNlaG9sZGVyKSB7XG4gICAgaWYgKG1hc2tQbGFjZWhvbGRlci5sZW5ndGggPT09IDEpIHtcbiAgICAgIG1hc2tQbGFjZWhvbGRlciA9IG1hc2subWFwKGZ1bmN0aW9uIChjaGFyYWN0ZXIsIGluZGV4KSB7XG4gICAgICAgIGlmIChwZXJtYW5lbnRzLmluZGV4T2YoaW5kZXgpICE9PSAtMSkge1xuICAgICAgICAgIHJldHVybiBjaGFyYWN0ZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFza1BsYWNlaG9sZGVyO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hc2tQbGFjZWhvbGRlciA9IG1hc2tQbGFjZWhvbGRlci5zcGxpdChcIlwiKTtcbiAgICB9XG5cbiAgICBwZXJtYW5lbnRzLmZvckVhY2goZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICBtYXNrUGxhY2Vob2xkZXJbcG9zaXRpb25dID0gbWFza1twb3NpdGlvbl07XG4gICAgfSk7XG4gICAgbWFza1BsYWNlaG9sZGVyID0gbWFza1BsYWNlaG9sZGVyLmpvaW4oXCJcIik7XG4gIH1cblxuICB2YXIgcHJlZml4ID0gcGVybWFuZW50cy5maWx0ZXIoZnVuY3Rpb24gKHBvc2l0aW9uLCBpbmRleCkge1xuICAgIHJldHVybiBwb3NpdGlvbiA9PT0gaW5kZXg7XG4gIH0pLm1hcChmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICByZXR1cm4gbWFza1twb3NpdGlvbl07XG4gIH0pLmpvaW4oXCJcIik7XG4gIHZhciBsYXN0RWRpdGFibGVQb3NpdGlvbiA9IG1hc2subGVuZ3RoIC0gMTtcblxuICB3aGlsZSAocGVybWFuZW50cy5pbmRleE9mKGxhc3RFZGl0YWJsZVBvc2l0aW9uKSAhPT0gLTEpIHtcbiAgICBsYXN0RWRpdGFibGVQb3NpdGlvbi0tO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtYXNrUGxhY2Vob2xkZXI6IG1hc2tQbGFjZWhvbGRlcixcbiAgICBwcmVmaXg6IHByZWZpeCxcbiAgICBtYXNrOiBtYXNrLFxuICAgIGxhc3RFZGl0YWJsZVBvc2l0aW9uOiBsYXN0RWRpdGFibGVQb3NpdGlvbixcbiAgICBwZXJtYW5lbnRzOiBwZXJtYW5lbnRzXG4gIH07XG59XG5cbi8qIGVzbGludCBuby11c2UtYmVmb3JlLWRlZmluZTogW1wiZXJyb3JcIiwgeyBmdW5jdGlvbnM6IGZhbHNlIH1dICovXG5cbnZhciBNYXNrVXRpbHMgPSBmdW5jdGlvbiBNYXNrVXRpbHMob3B0aW9ucykge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRoaXMuaXNDaGFyYWN0ZXJBbGxvd2VkQXRQb3NpdGlvbiA9IGZ1bmN0aW9uIChjaGFyYWN0ZXIsIHBvc2l0aW9uKSB7XG4gICAgdmFyIG1hc2tQbGFjZWhvbGRlciA9IF90aGlzLm1hc2tPcHRpb25zLm1hc2tQbGFjZWhvbGRlcjtcblxuICAgIGlmIChfdGhpcy5pc0NoYXJhY3RlckZpbGxpbmdQb3NpdGlvbihjaGFyYWN0ZXIsIHBvc2l0aW9uKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCFtYXNrUGxhY2Vob2xkZXIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFza1BsYWNlaG9sZGVyW3Bvc2l0aW9uXSA9PT0gY2hhcmFjdGVyO1xuICB9O1xuXG4gIHRoaXMuaXNDaGFyYWN0ZXJGaWxsaW5nUG9zaXRpb24gPSBmdW5jdGlvbiAoY2hhcmFjdGVyLCBwb3NpdGlvbikge1xuICAgIHZhciBtYXNrID0gX3RoaXMubWFza09wdGlvbnMubWFzaztcblxuICAgIGlmICghY2hhcmFjdGVyIHx8IHBvc2l0aW9uID49IG1hc2subGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFfdGhpcy5pc1Bvc2l0aW9uRWRpdGFibGUocG9zaXRpb24pKSB7XG4gICAgICByZXR1cm4gbWFza1twb3NpdGlvbl0gPT09IGNoYXJhY3RlcjtcbiAgICB9XG5cbiAgICB2YXIgY2hhclJ1bGUgPSBtYXNrW3Bvc2l0aW9uXTtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChjaGFyUnVsZSkudGVzdChjaGFyYWN0ZXIpO1xuICB9O1xuXG4gIHRoaXMuaXNQb3NpdGlvbkVkaXRhYmxlID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgdmFyIF90aGlzJG1hc2tPcHRpb25zID0gX3RoaXMubWFza09wdGlvbnMsXG4gICAgICAgIG1hc2sgPSBfdGhpcyRtYXNrT3B0aW9ucy5tYXNrLFxuICAgICAgICBwZXJtYW5lbnRzID0gX3RoaXMkbWFza09wdGlvbnMucGVybWFuZW50cztcbiAgICByZXR1cm4gcG9zaXRpb24gPCBtYXNrLmxlbmd0aCAmJiBwZXJtYW5lbnRzLmluZGV4T2YocG9zaXRpb24pID09PSAtMTtcbiAgfTtcblxuICB0aGlzLmlzVmFsdWVFbXB0eSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5zcGxpdChcIlwiKS5ldmVyeShmdW5jdGlvbiAoY2hhcmFjdGVyLCBwb3NpdGlvbikge1xuICAgICAgcmV0dXJuICFfdGhpcy5pc1Bvc2l0aW9uRWRpdGFibGUocG9zaXRpb24pIHx8ICFfdGhpcy5pc0NoYXJhY3RlckZpbGxpbmdQb3NpdGlvbihjaGFyYWN0ZXIsIHBvc2l0aW9uKTtcbiAgICB9KTtcbiAgfTtcblxuICB0aGlzLmlzVmFsdWVGaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gX3RoaXMuZ2V0RmlsbGVkTGVuZ3RoKHZhbHVlKSA9PT0gX3RoaXMubWFza09wdGlvbnMubGFzdEVkaXRhYmxlUG9zaXRpb24gKyAxO1xuICB9O1xuXG4gIHRoaXMuZ2V0RGVmYXVsdFNlbGVjdGlvbkZvclZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIGZpbGxlZExlbmd0aCA9IF90aGlzLmdldEZpbGxlZExlbmd0aCh2YWx1ZSk7XG5cbiAgICB2YXIgY3Vyc29yUG9zaXRpb24gPSBfdGhpcy5nZXRSaWdodEVkaXRhYmxlUG9zaXRpb24oZmlsbGVkTGVuZ3RoKTtcblxuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogY3Vyc29yUG9zaXRpb24sXG4gICAgICBlbmQ6IGN1cnNvclBvc2l0aW9uXG4gICAgfTtcbiAgfTtcblxuICB0aGlzLmdldEZpbGxlZExlbmd0aCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBjaGFyYWN0ZXJzID0gdmFsdWUuc3BsaXQoXCJcIik7XG4gICAgdmFyIGxhc3RGaWxsZWRJbmRleCA9IGZpbmRMYXN0SW5kZXgoY2hhcmFjdGVycywgZnVuY3Rpb24gKGNoYXJhY3RlciwgcG9zaXRpb24pIHtcbiAgICAgIHJldHVybiBfdGhpcy5pc1Bvc2l0aW9uRWRpdGFibGUocG9zaXRpb24pICYmIF90aGlzLmlzQ2hhcmFjdGVyRmlsbGluZ1Bvc2l0aW9uKGNoYXJhY3RlciwgcG9zaXRpb24pO1xuICAgIH0pO1xuICAgIHJldHVybiBsYXN0RmlsbGVkSW5kZXggKyAxO1xuICB9O1xuXG4gIHRoaXMuZ2V0U3RyaW5nRmlsbGluZ0xlbmd0aEF0UG9zaXRpb24gPSBmdW5jdGlvbiAoc3RyaW5nLCBwb3NpdGlvbikge1xuICAgIHZhciBjaGFyYWN0ZXJzID0gc3RyaW5nLnNwbGl0KFwiXCIpO1xuICAgIHZhciBpbnNlcnRlZFZhbHVlID0gY2hhcmFjdGVycy5yZWR1Y2UoZnVuY3Rpb24gKHZhbHVlLCBjaGFyYWN0ZXIpIHtcbiAgICAgIHJldHVybiBfdGhpcy5pbnNlcnRDaGFyYWN0ZXJBdFBvc2l0aW9uKHZhbHVlLCBjaGFyYWN0ZXIsIHZhbHVlLmxlbmd0aCk7XG4gICAgfSwgcmVwZWF0KFwiIFwiLCBwb3NpdGlvbikpO1xuICAgIHJldHVybiBpbnNlcnRlZFZhbHVlLmxlbmd0aCAtIHBvc2l0aW9uO1xuICB9O1xuXG4gIHRoaXMuZ2V0TGVmdEVkaXRhYmxlUG9zaXRpb24gPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICBmb3IgKHZhciBpID0gcG9zaXRpb247IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAoX3RoaXMuaXNQb3NpdGlvbkVkaXRhYmxlKGkpKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHRoaXMuZ2V0UmlnaHRFZGl0YWJsZVBvc2l0aW9uID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgdmFyIG1hc2sgPSBfdGhpcy5tYXNrT3B0aW9ucy5tYXNrO1xuXG4gICAgZm9yICh2YXIgaSA9IHBvc2l0aW9uOyBpIDwgbWFzay5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKF90aGlzLmlzUG9zaXRpb25FZGl0YWJsZShpKSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICB0aGlzLmZvcm1hdFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIF90aGlzJG1hc2tPcHRpb25zMiA9IF90aGlzLm1hc2tPcHRpb25zLFxuICAgICAgICBtYXNrUGxhY2Vob2xkZXIgPSBfdGhpcyRtYXNrT3B0aW9uczIubWFza1BsYWNlaG9sZGVyLFxuICAgICAgICBtYXNrID0gX3RoaXMkbWFza09wdGlvbnMyLm1hc2s7XG5cbiAgICBpZiAoIW1hc2tQbGFjZWhvbGRlcikge1xuICAgICAgdmFsdWUgPSBfdGhpcy5pbnNlcnRTdHJpbmdBdFBvc2l0aW9uKFwiXCIsIHZhbHVlLCAwKTtcblxuICAgICAgd2hpbGUgKHZhbHVlLmxlbmd0aCA8IG1hc2subGVuZ3RoICYmICFfdGhpcy5pc1Bvc2l0aW9uRWRpdGFibGUodmFsdWUubGVuZ3RoKSkge1xuICAgICAgICB2YWx1ZSArPSBtYXNrW3ZhbHVlLmxlbmd0aF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXMuaW5zZXJ0U3RyaW5nQXRQb3NpdGlvbihtYXNrUGxhY2Vob2xkZXIsIHZhbHVlLCAwKTtcbiAgfTtcblxuICB0aGlzLmNsZWFyUmFuZ2UgPSBmdW5jdGlvbiAodmFsdWUsIHN0YXJ0LCBsZW4pIHtcbiAgICBpZiAoIWxlbikge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBzdGFydCArIGxlbjtcbiAgICB2YXIgX3RoaXMkbWFza09wdGlvbnMzID0gX3RoaXMubWFza09wdGlvbnMsXG4gICAgICAgIG1hc2tQbGFjZWhvbGRlciA9IF90aGlzJG1hc2tPcHRpb25zMy5tYXNrUGxhY2Vob2xkZXIsXG4gICAgICAgIG1hc2sgPSBfdGhpcyRtYXNrT3B0aW9uczMubWFzaztcbiAgICB2YXIgY2xlYXJlZFZhbHVlID0gdmFsdWUuc3BsaXQoXCJcIikubWFwKGZ1bmN0aW9uIChjaGFyYWN0ZXIsIGkpIHtcbiAgICAgIHZhciBpc0VkaXRhYmxlID0gX3RoaXMuaXNQb3NpdGlvbkVkaXRhYmxlKGkpO1xuXG4gICAgICBpZiAoIW1hc2tQbGFjZWhvbGRlciAmJiBpID49IGVuZCAmJiAhaXNFZGl0YWJsZSkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPCBzdGFydCB8fCBpID49IGVuZCkge1xuICAgICAgICByZXR1cm4gY2hhcmFjdGVyO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzRWRpdGFibGUpIHtcbiAgICAgICAgcmV0dXJuIG1hc2tbaV07XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXNrUGxhY2Vob2xkZXIpIHtcbiAgICAgICAgcmV0dXJuIG1hc2tQbGFjZWhvbGRlcltpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfSkuam9pbihcIlwiKTtcbiAgICByZXR1cm4gX3RoaXMuZm9ybWF0VmFsdWUoY2xlYXJlZFZhbHVlKTtcbiAgfTtcblxuICB0aGlzLmluc2VydENoYXJhY3RlckF0UG9zaXRpb24gPSBmdW5jdGlvbiAodmFsdWUsIGNoYXJhY3RlciwgcG9zaXRpb24pIHtcbiAgICB2YXIgX3RoaXMkbWFza09wdGlvbnM0ID0gX3RoaXMubWFza09wdGlvbnMsXG4gICAgICAgIG1hc2sgPSBfdGhpcyRtYXNrT3B0aW9uczQubWFzayxcbiAgICAgICAgbWFza1BsYWNlaG9sZGVyID0gX3RoaXMkbWFza09wdGlvbnM0Lm1hc2tQbGFjZWhvbGRlcjtcblxuICAgIGlmIChwb3NpdGlvbiA+PSBtYXNrLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHZhciBpc0FsbG93ZWQgPSBfdGhpcy5pc0NoYXJhY3RlckFsbG93ZWRBdFBvc2l0aW9uKGNoYXJhY3RlciwgcG9zaXRpb24pO1xuXG4gICAgdmFyIGlzRWRpdGFibGUgPSBfdGhpcy5pc1Bvc2l0aW9uRWRpdGFibGUocG9zaXRpb24pO1xuXG4gICAgdmFyIG5leHRFZGl0YWJsZVBvc2l0aW9uID0gX3RoaXMuZ2V0UmlnaHRFZGl0YWJsZVBvc2l0aW9uKHBvc2l0aW9uKTtcblxuICAgIHZhciBpc05leHRQbGFjZWhvbGRlciA9IG1hc2tQbGFjZWhvbGRlciAmJiBuZXh0RWRpdGFibGVQb3NpdGlvbiA/IGNoYXJhY3RlciA9PT0gbWFza1BsYWNlaG9sZGVyW25leHRFZGl0YWJsZVBvc2l0aW9uXSA6IG51bGw7XG4gICAgdmFyIHZhbHVlQmVmb3JlID0gdmFsdWUuc2xpY2UoMCwgcG9zaXRpb24pO1xuXG4gICAgaWYgKGlzQWxsb3dlZCB8fCAhaXNFZGl0YWJsZSkge1xuICAgICAgdmFyIGluc2VydGVkQ2hhcmFjdGVyID0gaXNBbGxvd2VkID8gY2hhcmFjdGVyIDogbWFza1twb3NpdGlvbl07XG4gICAgICB2YWx1ZSA9IHZhbHVlQmVmb3JlICsgaW5zZXJ0ZWRDaGFyYWN0ZXI7XG4gICAgfVxuXG4gICAgaWYgKCFpc0FsbG93ZWQgJiYgIWlzRWRpdGFibGUgJiYgIWlzTmV4dFBsYWNlaG9sZGVyKSB7XG4gICAgICB2YWx1ZSA9IF90aGlzLmluc2VydENoYXJhY3RlckF0UG9zaXRpb24odmFsdWUsIGNoYXJhY3RlciwgcG9zaXRpb24gKyAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgdGhpcy5pbnNlcnRTdHJpbmdBdFBvc2l0aW9uID0gZnVuY3Rpb24gKHZhbHVlLCBzdHJpbmcsIHBvc2l0aW9uKSB7XG4gICAgdmFyIF90aGlzJG1hc2tPcHRpb25zNSA9IF90aGlzLm1hc2tPcHRpb25zLFxuICAgICAgICBtYXNrID0gX3RoaXMkbWFza09wdGlvbnM1Lm1hc2ssXG4gICAgICAgIG1hc2tQbGFjZWhvbGRlciA9IF90aGlzJG1hc2tPcHRpb25zNS5tYXNrUGxhY2Vob2xkZXI7XG5cbiAgICBpZiAoIXN0cmluZyB8fCBwb3NpdGlvbiA+PSBtYXNrLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHZhciBjaGFyYWN0ZXJzID0gc3RyaW5nLnNwbGl0KFwiXCIpO1xuICAgIHZhciBpc0ZpeGVkTGVuZ3RoID0gX3RoaXMuaXNWYWx1ZUZpbGxlZCh2YWx1ZSkgfHwgISFtYXNrUGxhY2Vob2xkZXI7XG4gICAgdmFyIHZhbHVlQWZ0ZXIgPSB2YWx1ZS5zbGljZShwb3NpdGlvbik7XG4gICAgdmFsdWUgPSBjaGFyYWN0ZXJzLnJlZHVjZShmdW5jdGlvbiAodmFsdWUsIGNoYXJhY3Rlcikge1xuICAgICAgcmV0dXJuIF90aGlzLmluc2VydENoYXJhY3RlckF0UG9zaXRpb24odmFsdWUsIGNoYXJhY3RlciwgdmFsdWUubGVuZ3RoKTtcbiAgICB9LCB2YWx1ZS5zbGljZSgwLCBwb3NpdGlvbikpO1xuXG4gICAgaWYgKGlzRml4ZWRMZW5ndGgpIHtcbiAgICAgIHZhbHVlICs9IHZhbHVlQWZ0ZXIuc2xpY2UodmFsdWUubGVuZ3RoIC0gcG9zaXRpb24pO1xuICAgIH0gZWxzZSBpZiAoX3RoaXMuaXNWYWx1ZUZpbGxlZCh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlICs9IG1hc2suc2xpY2UodmFsdWUubGVuZ3RoKS5qb2luKFwiXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZWRpdGFibGVDaGFyYWN0ZXJzQWZ0ZXIgPSB2YWx1ZUFmdGVyLnNwbGl0KFwiXCIpLmZpbHRlcihmdW5jdGlvbiAoY2hhcmFjdGVyLCBpKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5pc1Bvc2l0aW9uRWRpdGFibGUocG9zaXRpb24gKyBpKTtcbiAgICAgIH0pO1xuICAgICAgdmFsdWUgPSBlZGl0YWJsZUNoYXJhY3RlcnNBZnRlci5yZWR1Y2UoZnVuY3Rpb24gKHZhbHVlLCBjaGFyYWN0ZXIpIHtcbiAgICAgICAgdmFyIG5leHRFZGl0YWJsZVBvc2l0aW9uID0gX3RoaXMuZ2V0UmlnaHRFZGl0YWJsZVBvc2l0aW9uKHZhbHVlLmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKG5leHRFZGl0YWJsZVBvc2l0aW9uID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFfdGhpcy5pc1Bvc2l0aW9uRWRpdGFibGUodmFsdWUubGVuZ3RoKSkge1xuICAgICAgICAgIHZhbHVlICs9IG1hc2suc2xpY2UodmFsdWUubGVuZ3RoLCBuZXh0RWRpdGFibGVQb3NpdGlvbikuam9pbihcIlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfdGhpcy5pbnNlcnRDaGFyYWN0ZXJBdFBvc2l0aW9uKHZhbHVlLCBjaGFyYWN0ZXIsIHZhbHVlLmxlbmd0aCk7XG4gICAgICB9LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIHRoaXMucHJvY2Vzc0NoYW5nZSA9IGZ1bmN0aW9uIChjdXJyZW50U3RhdGUsIHByZXZpb3VzU3RhdGUpIHtcbiAgICB2YXIgX3RoaXMkbWFza09wdGlvbnM2ID0gX3RoaXMubWFza09wdGlvbnMsXG4gICAgICAgIG1hc2sgPSBfdGhpcyRtYXNrT3B0aW9uczYubWFzayxcbiAgICAgICAgcHJlZml4ID0gX3RoaXMkbWFza09wdGlvbnM2LnByZWZpeCxcbiAgICAgICAgbGFzdEVkaXRhYmxlUG9zaXRpb24gPSBfdGhpcyRtYXNrT3B0aW9uczYubGFzdEVkaXRhYmxlUG9zaXRpb247XG4gICAgdmFyIHZhbHVlID0gY3VycmVudFN0YXRlLnZhbHVlLFxuICAgICAgICBzZWxlY3Rpb24gPSBjdXJyZW50U3RhdGUuc2VsZWN0aW9uO1xuICAgIHZhciBwcmV2aW91c1ZhbHVlID0gcHJldmlvdXNTdGF0ZS52YWx1ZTtcbiAgICB2YXIgcHJldmlvdXNTZWxlY3Rpb24gPSBwcmV2aW91c1N0YXRlLnNlbGVjdGlvbjtcbiAgICB2YXIgbmV3VmFsdWUgPSB2YWx1ZTtcbiAgICB2YXIgZW50ZXJlZFN0cmluZyA9IFwiXCI7XG4gICAgdmFyIGZvcm1hdHRlZEVudGVyZWRTdHJpbmdMZW5ndGggPSAwO1xuICAgIHZhciByZW1vdmVkTGVuZ3RoID0gMDtcbiAgICB2YXIgY3Vyc29yUG9zaXRpb24gPSBNYXRoLm1pbihwcmV2aW91c1NlbGVjdGlvbi5zdGFydCwgc2VsZWN0aW9uLnN0YXJ0KTtcblxuICAgIGlmIChzZWxlY3Rpb24uZW5kID4gcHJldmlvdXNTZWxlY3Rpb24uc3RhcnQpIHtcbiAgICAgIGVudGVyZWRTdHJpbmcgPSBuZXdWYWx1ZS5zbGljZShwcmV2aW91c1NlbGVjdGlvbi5zdGFydCwgc2VsZWN0aW9uLmVuZCk7XG4gICAgICBmb3JtYXR0ZWRFbnRlcmVkU3RyaW5nTGVuZ3RoID0gX3RoaXMuZ2V0U3RyaW5nRmlsbGluZ0xlbmd0aEF0UG9zaXRpb24oZW50ZXJlZFN0cmluZywgY3Vyc29yUG9zaXRpb24pO1xuXG4gICAgICBpZiAoIWZvcm1hdHRlZEVudGVyZWRTdHJpbmdMZW5ndGgpIHtcbiAgICAgICAgcmVtb3ZlZExlbmd0aCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1vdmVkTGVuZ3RoID0gcHJldmlvdXNTZWxlY3Rpb24ubGVuZ3RoO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV3VmFsdWUubGVuZ3RoIDwgcHJldmlvdXNWYWx1ZS5sZW5ndGgpIHtcbiAgICAgIHJlbW92ZWRMZW5ndGggPSBwcmV2aW91c1ZhbHVlLmxlbmd0aCAtIG5ld1ZhbHVlLmxlbmd0aDtcbiAgICB9XG5cbiAgICBuZXdWYWx1ZSA9IHByZXZpb3VzVmFsdWU7XG5cbiAgICBpZiAocmVtb3ZlZExlbmd0aCkge1xuICAgICAgaWYgKHJlbW92ZWRMZW5ndGggPT09IDEgJiYgIXByZXZpb3VzU2VsZWN0aW9uLmxlbmd0aCkge1xuICAgICAgICB2YXIgZGVsZXRlRnJvbVJpZ2h0ID0gcHJldmlvdXNTZWxlY3Rpb24uc3RhcnQgPT09IHNlbGVjdGlvbi5zdGFydDtcbiAgICAgICAgY3Vyc29yUG9zaXRpb24gPSBkZWxldGVGcm9tUmlnaHQgPyBfdGhpcy5nZXRSaWdodEVkaXRhYmxlUG9zaXRpb24oc2VsZWN0aW9uLnN0YXJ0KSA6IF90aGlzLmdldExlZnRFZGl0YWJsZVBvc2l0aW9uKHNlbGVjdGlvbi5zdGFydCk7XG4gICAgICB9XG5cbiAgICAgIG5ld1ZhbHVlID0gX3RoaXMuY2xlYXJSYW5nZShuZXdWYWx1ZSwgY3Vyc29yUG9zaXRpb24sIHJlbW92ZWRMZW5ndGgpO1xuICAgIH1cblxuICAgIG5ld1ZhbHVlID0gX3RoaXMuaW5zZXJ0U3RyaW5nQXRQb3NpdGlvbihuZXdWYWx1ZSwgZW50ZXJlZFN0cmluZywgY3Vyc29yUG9zaXRpb24pO1xuICAgIGN1cnNvclBvc2l0aW9uICs9IGZvcm1hdHRlZEVudGVyZWRTdHJpbmdMZW5ndGg7XG5cbiAgICBpZiAoY3Vyc29yUG9zaXRpb24gPj0gbWFzay5sZW5ndGgpIHtcbiAgICAgIGN1cnNvclBvc2l0aW9uID0gbWFzay5sZW5ndGg7XG4gICAgfSBlbHNlIGlmIChjdXJzb3JQb3NpdGlvbiA8IHByZWZpeC5sZW5ndGggJiYgIWZvcm1hdHRlZEVudGVyZWRTdHJpbmdMZW5ndGgpIHtcbiAgICAgIGN1cnNvclBvc2l0aW9uID0gcHJlZml4Lmxlbmd0aDtcbiAgICB9IGVsc2UgaWYgKGN1cnNvclBvc2l0aW9uID49IHByZWZpeC5sZW5ndGggJiYgY3Vyc29yUG9zaXRpb24gPCBsYXN0RWRpdGFibGVQb3NpdGlvbiAmJiBmb3JtYXR0ZWRFbnRlcmVkU3RyaW5nTGVuZ3RoKSB7XG4gICAgICBjdXJzb3JQb3NpdGlvbiA9IF90aGlzLmdldFJpZ2h0RWRpdGFibGVQb3NpdGlvbihjdXJzb3JQb3NpdGlvbik7XG4gICAgfVxuXG4gICAgbmV3VmFsdWUgPSBfdGhpcy5mb3JtYXRWYWx1ZShuZXdWYWx1ZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgIGVudGVyZWRTdHJpbmc6IGVudGVyZWRTdHJpbmcsXG4gICAgICBzZWxlY3Rpb246IHtcbiAgICAgICAgc3RhcnQ6IGN1cnNvclBvc2l0aW9uLFxuICAgICAgICBlbmQ6IGN1cnNvclBvc2l0aW9uXG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICB0aGlzLm1hc2tPcHRpb25zID0gcGFyc2VNYXNrKG9wdGlvbnMpO1xufTtcblxudmFyIElucHV0TWFza0NoaWxkcmVuV3JhcHBlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShJbnB1dE1hc2tDaGlsZHJlbldyYXBwZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIElucHV0TWFza0NoaWxkcmVuV3JhcHBlcigpIHtcbiAgICByZXR1cm4gX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gSW5wdXRNYXNrQ2hpbGRyZW5XcmFwcGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9wcm9wLXR5cGVzXG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdGhpcyRwcm9wcywgW1wiY2hpbGRyZW5cIl0pO1xuXG4gICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNsb25lRWxlbWVudChjaGlsZHJlbiwgcHJvcHMpO1xuICB9O1xuXG4gIHJldHVybiBJbnB1dE1hc2tDaGlsZHJlbldyYXBwZXI7XG59KFJlYWN0X19kZWZhdWx0LkNvbXBvbmVudCk7XG5cbnZhciBJbnB1dE1hc2sgPSBSZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIElucHV0TWFzayhwcm9wcywgZm9yd2FyZGVkUmVmKSB7XG4gIHZhciBhbHdheXNTaG93TWFzayA9IHByb3BzLmFsd2F5c1Nob3dNYXNrLFxuICAgICAgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIG1hc2sgPSBwcm9wcy5tYXNrLFxuICAgICAgbWFza1BsYWNlaG9sZGVyID0gcHJvcHMubWFza1BsYWNlaG9sZGVyLFxuICAgICAgYmVmb3JlTWFza2VkU3RhdGVDaGFuZ2UgPSBwcm9wcy5iZWZvcmVNYXNrZWRTdGF0ZUNoYW5nZSxcbiAgICAgIHJlc3RQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBbXCJhbHdheXNTaG93TWFza1wiLCBcImNoaWxkcmVuXCIsIFwibWFza1wiLCBcIm1hc2tQbGFjZWhvbGRlclwiLCBcImJlZm9yZU1hc2tlZFN0YXRlQ2hhbmdlXCJdKTtcblxuICB2YWxpZGF0ZU1heExlbmd0aChwcm9wcyk7XG4gIHZhbGlkYXRlTWFza1BsYWNlaG9sZGVyKHByb3BzKTtcbiAgdmFyIG1hc2tVdGlscyA9IG5ldyBNYXNrVXRpbHMoe1xuICAgIG1hc2s6IG1hc2ssXG4gICAgbWFza1BsYWNlaG9sZGVyOiBtYXNrUGxhY2Vob2xkZXJcbiAgfSk7XG4gIHZhciBpc01hc2tlZCA9ICEhbWFzaztcbiAgdmFyIGlzRWRpdGFibGUgPSAhcmVzdFByb3BzLmRpc2FibGVkICYmICFyZXN0UHJvcHMucmVhZE9ubHk7XG4gIHZhciBpc0NvbnRyb2xsZWQgPSBwcm9wcy52YWx1ZSAhPT0gbnVsbCAmJiBwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNJc01hc2tlZCA9IHVzZVByZXZpb3VzKGlzTWFza2VkKTtcbiAgdmFyIGluaXRpYWxWYWx1ZSA9IHRvU3RyaW5nKChpc0NvbnRyb2xsZWQgPyBwcm9wcy52YWx1ZSA6IHByb3BzLmRlZmF1bHRWYWx1ZSkgfHwgXCJcIik7XG5cbiAgdmFyIF91c2VJbnB1dFN0YXRlID0gdXNlSW5wdXRTdGF0ZShpbml0aWFsVmFsdWUsIGlzTWFza2VkKSxcbiAgICAgIGlucHV0UmVmID0gX3VzZUlucHV0U3RhdGUuaW5wdXRSZWYsXG4gICAgICBnZXRJbnB1dFN0YXRlID0gX3VzZUlucHV0U3RhdGUuZ2V0SW5wdXRTdGF0ZSxcbiAgICAgIHNldElucHV0U3RhdGUgPSBfdXNlSW5wdXRTdGF0ZS5zZXRJbnB1dFN0YXRlLFxuICAgICAgZ2V0TGFzdElucHV0U3RhdGUgPSBfdXNlSW5wdXRTdGF0ZS5nZXRMYXN0SW5wdXRTdGF0ZTtcblxuICB2YXIgZ2V0SW5wdXRFbGVtZW50ID0gdXNlSW5wdXRFbGVtZW50KGlucHV0UmVmKTtcblxuICBmdW5jdGlvbiBvbkNoYW5nZShldmVudCkge1xuICAgIHZhciBjdXJyZW50U3RhdGUgPSBnZXRJbnB1dFN0YXRlKCk7XG4gICAgdmFyIHByZXZpb3VzU3RhdGUgPSBnZXRMYXN0SW5wdXRTdGF0ZSgpO1xuICAgIHZhciBuZXdJbnB1dFN0YXRlID0gbWFza1V0aWxzLnByb2Nlc3NDaGFuZ2UoY3VycmVudFN0YXRlLCBwcmV2aW91c1N0YXRlKTtcblxuICAgIGlmIChiZWZvcmVNYXNrZWRTdGF0ZUNoYW5nZSkge1xuICAgICAgbmV3SW5wdXRTdGF0ZSA9IGJlZm9yZU1hc2tlZFN0YXRlQ2hhbmdlKHtcbiAgICAgICAgY3VycmVudFN0YXRlOiBjdXJyZW50U3RhdGUsXG4gICAgICAgIHByZXZpb3VzU3RhdGU6IHByZXZpb3VzU3RhdGUsXG4gICAgICAgIG5leHRTdGF0ZTogbmV3SW5wdXRTdGF0ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2V0SW5wdXRTdGF0ZShuZXdJbnB1dFN0YXRlKTtcblxuICAgIGlmIChwcm9wcy5vbkNoYW5nZSkge1xuICAgICAgcHJvcHMub25DaGFuZ2UoZXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRm9jdXMoZXZlbnQpIHtcbiAgICAvLyBJZiBhdXRvRm9jdXMgcHJvcGVydHkgaXMgc2V0LCBmb2N1cyBldmVudCBmaXJlcyBiZWZvcmUgdGhlIHJlZiBoYW5kbGVyIGdldHMgY2FsbGVkXG4gICAgaW5wdXRSZWYuY3VycmVudCA9IGV2ZW50LnRhcmdldDtcbiAgICB2YXIgY3VycmVudFZhbHVlID0gZ2V0SW5wdXRTdGF0ZSgpLnZhbHVlO1xuXG4gICAgaWYgKGlzTWFza2VkICYmICFtYXNrVXRpbHMuaXNWYWx1ZUZpbGxlZChjdXJyZW50VmFsdWUpKSB7XG4gICAgICB2YXIgbmV3VmFsdWUgPSBtYXNrVXRpbHMuZm9ybWF0VmFsdWUoY3VycmVudFZhbHVlKTtcbiAgICAgIHZhciBuZXdTZWxlY3Rpb24gPSBtYXNrVXRpbHMuZ2V0RGVmYXVsdFNlbGVjdGlvbkZvclZhbHVlKG5ld1ZhbHVlKTtcbiAgICAgIHZhciBuZXdJbnB1dFN0YXRlID0ge1xuICAgICAgICB2YWx1ZTogbmV3VmFsdWUsXG4gICAgICAgIHNlbGVjdGlvbjogbmV3U2VsZWN0aW9uXG4gICAgICB9O1xuXG4gICAgICBpZiAoYmVmb3JlTWFza2VkU3RhdGVDaGFuZ2UpIHtcbiAgICAgICAgbmV3SW5wdXRTdGF0ZSA9IGJlZm9yZU1hc2tlZFN0YXRlQ2hhbmdlKHtcbiAgICAgICAgICBjdXJyZW50U3RhdGU6IGdldElucHV0U3RhdGUoKSxcbiAgICAgICAgICBuZXh0U3RhdGU6IG5ld0lucHV0U3RhdGVcbiAgICAgICAgfSk7XG4gICAgICAgIG5ld1ZhbHVlID0gbmV3SW5wdXRTdGF0ZS52YWx1ZTtcbiAgICAgICAgbmV3U2VsZWN0aW9uID0gbmV3SW5wdXRTdGF0ZS5zZWxlY3Rpb247XG4gICAgICB9XG5cbiAgICAgIHNldElucHV0U3RhdGUobmV3SW5wdXRTdGF0ZSk7XG5cbiAgICAgIGlmIChuZXdWYWx1ZSAhPT0gY3VycmVudFZhbHVlICYmIHByb3BzLm9uQ2hhbmdlKSB7XG4gICAgICAgIHByb3BzLm9uQ2hhbmdlKGV2ZW50KTtcbiAgICAgIH0gLy8gQ2hyb21lIHJlc2V0cyBzZWxlY3Rpb24gYWZ0ZXIgZm9jdXMgZXZlbnQsXG4gICAgICAvLyBzbyB3ZSB3YW50IHRvIHJlc3RvcmUgaXQgbGF0ZXJcblxuXG4gICAgICBkZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldElucHV0U3RhdGUoZ2V0TGFzdElucHV0U3RhdGUoKSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMub25Gb2N1cykge1xuICAgICAgcHJvcHMub25Gb2N1cyhldmVudCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25CbHVyKGV2ZW50KSB7XG4gICAgdmFyIGN1cnJlbnRWYWx1ZSA9IGdldElucHV0U3RhdGUoKS52YWx1ZTtcbiAgICB2YXIgbGFzdFZhbHVlID0gZ2V0TGFzdElucHV0U3RhdGUoKS52YWx1ZTtcblxuICAgIGlmIChpc01hc2tlZCAmJiAhYWx3YXlzU2hvd01hc2sgJiYgbWFza1V0aWxzLmlzVmFsdWVFbXB0eShsYXN0VmFsdWUpKSB7XG4gICAgICB2YXIgbmV3VmFsdWUgPSBcIlwiO1xuICAgICAgdmFyIG5ld0lucHV0U3RhdGUgPSB7XG4gICAgICAgIHZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgc2VsZWN0aW9uOiB7XG4gICAgICAgICAgc3RhcnQ6IG51bGwsXG4gICAgICAgICAgZW5kOiBudWxsXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChiZWZvcmVNYXNrZWRTdGF0ZUNoYW5nZSkge1xuICAgICAgICBuZXdJbnB1dFN0YXRlID0gYmVmb3JlTWFza2VkU3RhdGVDaGFuZ2Uoe1xuICAgICAgICAgIGN1cnJlbnRTdGF0ZTogZ2V0SW5wdXRTdGF0ZSgpLFxuICAgICAgICAgIG5leHRTdGF0ZTogbmV3SW5wdXRTdGF0ZVxuICAgICAgICB9KTtcbiAgICAgICAgbmV3VmFsdWUgPSBuZXdJbnB1dFN0YXRlLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICBzZXRJbnB1dFN0YXRlKG5ld0lucHV0U3RhdGUpO1xuXG4gICAgICBpZiAobmV3VmFsdWUgIT09IGN1cnJlbnRWYWx1ZSAmJiBwcm9wcy5vbkNoYW5nZSkge1xuICAgICAgICBwcm9wcy5vbkNoYW5nZShldmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb3BzLm9uQmx1cikge1xuICAgICAgcHJvcHMub25CbHVyKGV2ZW50KTtcbiAgICB9XG4gIH0gLy8gVGlueSB1bmludGVudGlvbmFsIG1vdXNlIG1vdmVtZW50cyBjYW4gYnJlYWsgY3Vyc29yXG4gIC8vIHBvc2l0aW9uIG9uIGZvY3VzLCBzbyB3ZSBoYXZlIHRvIHJlc3RvcmUgaXQgaW4gdGhhdCBjYXNlXG4gIC8vXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zYW5uaWFzc2luL3JlYWN0LWlucHV0LW1hc2svaXNzdWVzLzEwOFxuXG5cbiAgZnVuY3Rpb24gb25Nb3VzZURvd24oZXZlbnQpIHtcbiAgICB2YXIgaW5wdXQgPSBnZXRJbnB1dEVsZW1lbnQoKTtcblxuICAgIHZhciBfZ2V0SW5wdXRTdGF0ZSA9IGdldElucHV0U3RhdGUoKSxcbiAgICAgICAgdmFsdWUgPSBfZ2V0SW5wdXRTdGF0ZS52YWx1ZTtcblxuICAgIHZhciBpbnB1dERvY3VtZW50ID0gZ2V0RWxlbWVudERvY3VtZW50KGlucHV0KTtcblxuICAgIGlmICghaXNJbnB1dEZvY3VzZWQoaW5wdXQpICYmICFtYXNrVXRpbHMuaXNWYWx1ZUZpbGxlZCh2YWx1ZSkpIHtcbiAgICAgIHZhciBtb3VzZURvd25YID0gZXZlbnQuY2xpZW50WDtcbiAgICAgIHZhciBtb3VzZURvd25ZID0gZXZlbnQuY2xpZW50WTtcbiAgICAgIHZhciBtb3VzZURvd25UaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgICAgIHZhciBtb3VzZVVwSGFuZGxlciA9IGZ1bmN0aW9uIG1vdXNlVXBIYW5kbGVyKG1vdXNlVXBFdmVudCkge1xuICAgICAgICBpbnB1dERvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIG1vdXNlVXBIYW5kbGVyKTtcblxuICAgICAgICBpZiAoIWlzSW5wdXRGb2N1c2VkKGlucHV0KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWx0YVggPSBNYXRoLmFicyhtb3VzZVVwRXZlbnQuY2xpZW50WCAtIG1vdXNlRG93blgpO1xuICAgICAgICB2YXIgZGVsdGFZID0gTWF0aC5hYnMobW91c2VVcEV2ZW50LmNsaWVudFkgLSBtb3VzZURvd25ZKTtcbiAgICAgICAgdmFyIGF4aXNEZWx0YSA9IE1hdGgubWF4KGRlbHRhWCwgZGVsdGFZKTtcbiAgICAgICAgdmFyIHRpbWVEZWx0YSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gbW91c2VEb3duVGltZTtcblxuICAgICAgICBpZiAoYXhpc0RlbHRhIDw9IDEwICYmIHRpbWVEZWx0YSA8PSAyMDAgfHwgYXhpc0RlbHRhIDw9IDUgJiYgdGltZURlbHRhIDw9IDMwMCkge1xuICAgICAgICAgIHZhciBfbGFzdFN0YXRlID0gZ2V0TGFzdElucHV0U3RhdGUoKTtcblxuICAgICAgICAgIHZhciBuZXdTZWxlY3Rpb24gPSBtYXNrVXRpbHMuZ2V0RGVmYXVsdFNlbGVjdGlvbkZvclZhbHVlKF9sYXN0U3RhdGUudmFsdWUpO1xuXG4gICAgICAgICAgdmFyIG5ld1N0YXRlID0gX2V4dGVuZHMoe30sIF9sYXN0U3RhdGUsIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbjogbmV3U2VsZWN0aW9uXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBzZXRJbnB1dFN0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaW5wdXREb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBtb3VzZVVwSGFuZGxlcik7XG4gICAgfVxuXG4gICAgaWYgKHByb3BzLm9uTW91c2VEb3duKSB7XG4gICAgICBwcm9wcy5vbk1vdXNlRG93bihldmVudCk7XG4gICAgfVxuICB9IC8vIEZvciBjb250cm9sbGVkIGlucHV0cyB3ZSB3YW50IHRvIHByb3ZpZGUgcHJvcGVybHkgZm9ybWF0dGVkXG4gIC8vIHZhbHVlIHByb3BcblxuXG4gIGlmIChpc01hc2tlZCAmJiBpc0NvbnRyb2xsZWQpIHtcbiAgICB2YXIgaW5wdXQgPSBnZXRJbnB1dEVsZW1lbnQoKTtcbiAgICB2YXIgaXNGb2N1c2VkID0gaW5wdXQgJiYgaXNJbnB1dEZvY3VzZWQoaW5wdXQpO1xuICAgIHZhciBuZXdWYWx1ZSA9IGlzRm9jdXNlZCB8fCBhbHdheXNTaG93TWFzayB8fCBwcm9wcy52YWx1ZSA/IG1hc2tVdGlscy5mb3JtYXRWYWx1ZShwcm9wcy52YWx1ZSkgOiBwcm9wcy52YWx1ZTtcblxuICAgIGlmIChiZWZvcmVNYXNrZWRTdGF0ZUNoYW5nZSkge1xuICAgICAgbmV3VmFsdWUgPSBiZWZvcmVNYXNrZWRTdGF0ZUNoYW5nZSh7XG4gICAgICAgIG5leHRTdGF0ZToge1xuICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICBzZWxlY3Rpb246IHtcbiAgICAgICAgICAgIHN0YXJ0OiBudWxsLFxuICAgICAgICAgICAgZW5kOiBudWxsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KS52YWx1ZTtcbiAgICB9XG5cbiAgICBzZXRJbnB1dFN0YXRlKF9leHRlbmRzKHt9LCBnZXRMYXN0SW5wdXRTdGF0ZSgpLCB7XG4gICAgICB2YWx1ZTogbmV3VmFsdWVcbiAgICB9KSk7XG4gIH1cblxuICB2YXIgbGFzdFN0YXRlID0gZ2V0TGFzdElucHV0U3RhdGUoKTtcbiAgdmFyIGxhc3RTZWxlY3Rpb24gPSBsYXN0U3RhdGUuc2VsZWN0aW9uO1xuICB2YXIgbGFzdFZhbHVlID0gbGFzdFN0YXRlLnZhbHVlO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICghaXNNYXNrZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaW5wdXQgPSBnZXRJbnB1dEVsZW1lbnQoKTtcbiAgICB2YXIgaXNGb2N1c2VkID0gaXNJbnB1dEZvY3VzZWQoaW5wdXQpO1xuICAgIHZhciBwcmV2aW91c1NlbGVjdGlvbiA9IGxhc3RTZWxlY3Rpb247XG4gICAgdmFyIGN1cnJlbnRTdGF0ZSA9IGdldElucHV0U3RhdGUoKTtcblxuICAgIHZhciBuZXdJbnB1dFN0YXRlID0gX2V4dGVuZHMoe30sIGN1cnJlbnRTdGF0ZSk7IC8vIFVwZGF0ZSB2YWx1ZSBmb3IgdW5jb250cm9sbGVkIGlucHV0cyB0byBtYWtlIHN1cmVcbiAgICAvLyBpdCdzIGFsd2F5cyBpbiBzeW5jIHdpdGggbWFzayBwcm9wc1xuXG5cbiAgICBpZiAoIWlzQ29udHJvbGxlZCkge1xuICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IGN1cnJlbnRTdGF0ZS52YWx1ZTtcbiAgICAgIHZhciBmb3JtYXR0ZWRWYWx1ZSA9IG1hc2tVdGlscy5mb3JtYXRWYWx1ZShjdXJyZW50VmFsdWUpO1xuICAgICAgdmFyIGlzVmFsdWVFbXB0eSA9IG1hc2tVdGlscy5pc1ZhbHVlRW1wdHkoZm9ybWF0dGVkVmFsdWUpO1xuICAgICAgdmFyIHNob3VsZEZvcm1hdFZhbHVlID0gIWlzVmFsdWVFbXB0eSB8fCBpc0ZvY3VzZWQgfHwgYWx3YXlzU2hvd01hc2s7XG5cbiAgICAgIGlmIChzaG91bGRGb3JtYXRWYWx1ZSkge1xuICAgICAgICBuZXdJbnB1dFN0YXRlLnZhbHVlID0gZm9ybWF0dGVkVmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKGlzVmFsdWVFbXB0eSAmJiAhaXNGb2N1c2VkKSB7XG4gICAgICAgIG5ld0lucHV0U3RhdGUudmFsdWUgPSBcIlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0ZvY3VzZWQgJiYgIXByZXZpb3VzSXNNYXNrZWQpIHtcbiAgICAgIC8vIEFkanVzdCBzZWxlY3Rpb24gaWYgaW5wdXQgZ290IG1hc2tlZCB3aGlsZSBiZWluZyBmb2N1c2VkXG4gICAgICBuZXdJbnB1dFN0YXRlLnNlbGVjdGlvbiA9IG1hc2tVdGlscy5nZXREZWZhdWx0U2VsZWN0aW9uRm9yVmFsdWUobmV3SW5wdXRTdGF0ZS52YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChpc0NvbnRyb2xsZWQgJiYgaXNGb2N1c2VkICYmIHByZXZpb3VzU2VsZWN0aW9uKSB7XG4gICAgICAvLyBSZXN0b3JlIGN1cnNvciBwb3NpdGlvbiBpZiB2YWx1ZSBoYXMgY2hhbmdlZCBvdXRzaWRlIGNoYW5nZSBldmVudFxuICAgICAgaWYgKHByZXZpb3VzU2VsZWN0aW9uLnN0YXJ0ICE9PSBudWxsICYmIHByZXZpb3VzU2VsZWN0aW9uLmVuZCAhPT0gbnVsbCkge1xuICAgICAgICBuZXdJbnB1dFN0YXRlLnNlbGVjdGlvbiA9IHByZXZpb3VzU2VsZWN0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChiZWZvcmVNYXNrZWRTdGF0ZUNoYW5nZSkge1xuICAgICAgbmV3SW5wdXRTdGF0ZSA9IGJlZm9yZU1hc2tlZFN0YXRlQ2hhbmdlKHtcbiAgICAgICAgY3VycmVudFN0YXRlOiBjdXJyZW50U3RhdGUsXG4gICAgICAgIG5leHRTdGF0ZTogbmV3SW5wdXRTdGF0ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2V0SW5wdXRTdGF0ZShuZXdJbnB1dFN0YXRlKTtcbiAgfSk7XG5cbiAgdmFyIGlucHV0UHJvcHMgPSBfZXh0ZW5kcyh7fSwgcmVzdFByb3BzLCB7XG4gICAgb25Gb2N1czogb25Gb2N1cyxcbiAgICBvbkJsdXI6IG9uQmx1cixcbiAgICBvbkNoYW5nZTogaXNNYXNrZWQgJiYgaXNFZGl0YWJsZSA/IG9uQ2hhbmdlIDogcHJvcHMub25DaGFuZ2UsXG4gICAgb25Nb3VzZURvd246IGlzTWFza2VkICYmIGlzRWRpdGFibGUgPyBvbk1vdXNlRG93biA6IHByb3BzLm9uTW91c2VEb3duLFxuICAgIHJlZjogZnVuY3Rpb24gcmVmKF9yZWYpIHtcbiAgICAgIGlucHV0UmVmLmN1cnJlbnQgPSByZWFjdERvbS5maW5kRE9NTm9kZShfcmVmKTtcblxuICAgICAgaWYgKGlzRnVuY3Rpb24oZm9yd2FyZGVkUmVmKSkge1xuICAgICAgICBmb3J3YXJkZWRSZWYoX3JlZik7XG4gICAgICB9IGVsc2UgaWYgKGZvcndhcmRlZFJlZiAhPT0gbnVsbCAmJiB0eXBlb2YgZm9yd2FyZGVkUmVmID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGZvcndhcmRlZFJlZi5jdXJyZW50ID0gX3JlZjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbHVlOiBpc01hc2tlZCAmJiBpc0NvbnRyb2xsZWQgPyBsYXN0VmFsdWUgOiBwcm9wcy52YWx1ZVxuICB9KTtcblxuICBpZiAoY2hpbGRyZW4pIHtcbiAgICB2YWxpZGF0ZUNoaWxkcmVuKHByb3BzLCBjaGlsZHJlbik7IC8vIFdlIHdyYXAgY2hpbGRyZW4gaW50byBhIGNsYXNzIGNvbXBvbmVudCB0byBiZSBhYmxlIHRvIGZpbmRcbiAgICAvLyB0aGVpciBpbnB1dCBlbGVtZW50IHVzaW5nIGZpbmRET01Ob2RlXG5cbiAgICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChJbnB1dE1hc2tDaGlsZHJlbldyYXBwZXIsIGlucHV0UHJvcHMsIGNoaWxkcmVuKTtcbiAgfVxuXG4gIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwgaW5wdXRQcm9wcyk7XG59KTtcbklucHV0TWFzay5kaXNwbGF5TmFtZSA9IFwiSW5wdXRNYXNrXCI7XG5JbnB1dE1hc2suZGVmYXVsdFByb3BzID0ge1xuICBhbHdheXNTaG93TWFzazogZmFsc2UsXG4gIG1hc2tQbGFjZWhvbGRlcjogXCJfXCJcbn07XG5JbnB1dE1hc2sucHJvcFR5cGVzID0ge1xuICBhbHdheXNTaG93TWFzazogUHJvcFR5cGVzLmJvb2wsXG4gIGJlZm9yZU1hc2tlZFN0YXRlQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5lbGVtZW50LFxuICBtYXNrOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuaW5zdGFuY2VPZihSZWdFeHApXSkpXSksXG4gIG1hc2tQbGFjZWhvbGRlcjogUHJvcFR5cGVzLnN0cmluZyxcbiAgb25Gb2N1czogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uQmx1cjogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Nb3VzZURvd246IFByb3BUeXBlcy5mdW5jXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IElucHV0TWFzaztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-input-mask/lib/react-input-mask.development.js\n");

/***/ })

};
;